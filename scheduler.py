"""
FunnelWeb: Decide which tile to observe next, based on sidereal time and observing conditions (weather, seeing etc.).
"""

# Should this code select only one tile to be observe next, or a few best candidates?

# Assumption: none of the tiles from the input file have not been observed yet. If Scheduler is run muptiple times during the night make sure you exclude tiles that have already been observed this night.
# Tiling will be run about once per month anyway so there should be a list of observed tiles.


import numpy as np
import math
import random
import pickle
import json
import datetime
from collections import defaultdict

from astropy.time import Time
from astropy.coordinates import get_moon
from astropy.coordinates import SkyCoord
from astropy.coordinates.earth import EarthLocation
import astropy.units as u
from astroplan import Observer
from astroplan import FixedTarget

import line_profiler

# Taipan
import taipan.core as tp
# Have to run the code in python 2. Astropy requires numpy>1.9.1. How to do that? It doesn't work with pip

"""
Constants
"""
# Minimal and maximal allowed altitude of the center of the tile
ALT_MIN=27.0
ALT_MAX=85.0

ALTITUDE_LOW_FRACTION = 0.8 # Fraction = Current altitude / altitude at local meridian. Altitude_low_fraction is thus the lowest acceptable fraction for a tile to be observed.

HOUR_ANGLE_AMP = 3 # hours, consider only tiles with H = +/- HOUR_ANGLE_AMP
# But be careful: when moon is on the local meridian, what happens?

# Minimal angular Moon distance
MOON_ANGDIST_MIN=20.0

TIME_PER_TILE=30#10 # [minutes], 10 minutes altogether per tile
SLEW_TIME_MIN=60.0 # [seconds], take slew time into consideration above this limit

TILE_DENSITY_RADIUS=15.0 #deg, radius to compute observed tile surface density

"""
Observer's coordinates
"""
# Siding Spring Observatory
# TODO: this data is automatic result from Google. Check if it is correct.
LAT=-31.2749 # deg South
LON=149.0685 # deg East


"""
Read the data
"""
tiling_filename='171308_1647_fw_tiling.pkl'
try:
    tiles = data[0]#[:10]
    settings = data[2]
except NameError:
    print 'Reading data...'
    fl = open(tiling_filename,'rb')
    data = pickle.load(fl)
    fl.close()				

    tiles = data[0]#[:10]
    settings = data[2]

print 'Number of tiles:', len(tiles)



class Scheduler():
    """
    Schedule FunnelWeb tile observations.
    """
    def __init__(self, tiling_filename=None, observed_tiles_filename=None, weather_data_filename=None, alt_min=None, alt_max=None, ra_min=None, ra_max=None, moon_angdist_min=None, lat=None, lon=None, desired_priority=None, minimal_priority=None, time_per_tile=TIME_PER_TILE, limiting_magnitude=None, slew_time_min=SLEW_TIME_MIN, ra_current=None, dec_current=None, tile_density_radius=TILE_DENSITY_RADIUS, altitude_low_fraction=ALTITUDE_LOW_FRACTION):
        """
        Parameters
        ----------
        tiling_filename: string
            A pickle data filename of tiles generated by the tiling code.
        observed_tiles_filename: string
            A file with a list of tile IDs (a list of integers) that have already been observed. TODO: MAKE SURE THAT TILE IDs ARE UNIQUE.
        weather_data_filename: string
            Filename of the weather data.
        alt_min: float, degrees
            Minimal allowed altitude of a tile above the horizon. Default: 30.0.
        alt_max: float, degrees
            Maximal allowed altitude of a tile. (Avoid observing zenith). Default: 70.0.
        ra_min, ra_max: float, degrees
            Limit tiles within certain RA limits (e.g. when only part of the sky is clear).
        moon_angdist_min: float, degrees
            Angular distance between the Moon and the tile. Default: 20.0.
        lat, lon: float, degrees
            Observer's latitude and longitude. Default: lat=-31.2749, lon=149.0685 (Siding Spring).
        desired_priority: float
            Desired priority to be observed.
        minimal_priority: float
            User defined minimal tile priority to be observed.
        processing_time: float, seconds
            Total time spend per tile (slewing, exposure, calibration etc.). Default: 300.0.
        limiting_magnitude: float
            Magnitude of a faintest star to be observed. Default: None.
        ra_current, dec_current: float, degrees
            Current position of telescope. This position is needed to determine slew time to the next target.
            
            
        Data needed from Jeeves:
            ra_current, dec_current
            weather
        
        """
        
        """
        Read the data
        """
        #~ if tiling_filename:
            #~ try:
                #~ self.tiles = data[0]#[:10]
                #~ self.settings = data[2]
            #~ except NameError:
                #~ print 'Reading data...'
                #~ fl = open(tiling_filename,'rb')
                #~ data = pickle.load(fl)
                #~ fl.close()				
            
                #~ self.tiles = data[0]#[:10]
                #~ self.settings = data[2]
            
            #~ print 'Number of tiles:', len(self.tiles)
        #~ else:
            #~ print 'tiling_filename is None.'
            #~ exit(0)

        self.tiles = tiles
        self.settings = settings


        if weather_data_filename:
            self.weather_data=np.loadtxt(weather_data_filename) # STRING!!
        else:
            self.weather_data=None
        
        """
        Determine field_id and priority.
        Calculate_the_score should remain here.
        """
        # TODO: Later remove field_id as tile_id will be already available in the TaipanTiles.
        tiles2=[]
        priorities=[]
        #~ print 'WARNING: CORRECT TILE PRIORITIES!'
        for tile_id, x in enumerate(self.tiles):
            x.field_id=tile_id
            prior=x.calculate_tile_score(method=self.settings['ranking_method'], disqualify_below_min=self.settings['disqualify_below_min'], combined_weight=self.settings['combined_weight'], exp_base=self.settings['exp_base'])
            x.priority=prior
            priorities.append(prior)
            tiles2.append(x)
        self.tiles=tiles2
        self.max_priority=np.max(priorities)


        self.observed_tiles_filename=observed_tiles_filename
        self.manage_observed_tiles()
        
        self.tile_density_radius=tile_density_radius
        
        
        """
        Global tile density of observed tiles: N(observed) / N(total) for each magnitude range
        """

        # Group tiles per magnitude range
        tiles_mag_range = defaultdict(list)
        for x in self.tiles:
            tiles_mag_range[tuple([float(x.mag_min), float(x.mag_max)])].append(x)
        self.tiles_mag_range={k: v for k, v in tiles_mag_range.iteritems()}

        """
        Observer's coordinates
        """
        if lat:
            self.lat=lat
        else:
            self.lat=LAT
        if lon:
            self.lon=lon
        else:
            self.lon=LON

        #observatory=EarthLocation('Anglo-Australian Observatory')
        #~ observatory = Observer(at_site="Anglo-Australian Observatory")
        #~ sun_set = apo.sun_set_time(time, which="next")


        # Observatory
        self.observatory = Observer.at_site("Anglo-Australian Observatory") # TODO: enter LAT and LON coordinates
        
        # Determine sunset and sunrise times
        datenow=datetime.datetime.now().date()
        date='%d-%02d-%02d'%(datenow.year, datenow.month, datenow.day)
        time = Time('%s 23:30:00'%date)
        
        self.sun_set = self.observatory.sun_set_time(time, which="previous").datetime
        self.sun_rise = self.observatory.sun_rise_time(time, which="previous").datetime # previous. This is correct.



        """
        Minimal altitude of a tile above the horizon.
        """
        if alt_min:
            if alt_min>ALT_MIN:
                self.alt_min=alt_min
            else: # user is not allowed to do funny things
                self.alt_min=ALT_MIN
                print 'WARNING: Minimal altitude too low. Set to %g degrees.'%ALT_MIN
        else:
            self.alt_min = ALT_MIN # degrees


        """
        Maximal tile altitude valid to observe - due to technical obstacles (cannot observe zenith). ???? DO WE NEED THIS?
        """
        if alt_max:
            if alt_max<ALT_MAX:
                self.alt_max=alt_max
            else: # user is not allowed to do funny things
                self.alt_max=ALT_MAX
                print 'WARNING: Maximal altitude limit too high. Set to %g degrees.'%ALT_MAX
        else:
            self.alt_max = ALT_MAX # degrees

        self.altitude_low_fraction = ALTITUDE_LOW_FRACTION


        """
        Limit RA in case of partly cloudy sky.
        """
        if ra_min:
            if ra_min>1e-10 and ra_min<360.0+1e-10:
                self.ra_min=ra_min
            else:
                self.ra_min=None
                print 'WARNING: You must enter 0 < ra_min < 360.'
        else:
            self.ra_min=None
            
        if ra_max:
            if ra_max>1e-10 and ra_max<360.0+1e-10:
                self.ra_max=ra_max
            else:
                self.ra_max=None
                print 'WARNING: You must enter 0 < ra_max < 360.'
        else:
            self.ra_max=None

        if self.ra_min and self.ra_max:
            if self.ra_min>self.ra_max or np.abs(self.ra_min-self.ra_max)<1e-6:
                print 'WARNING: ra_min and ra_max are not within valid limits or ra_min>ra_max.'

        self.hour_angle_amp = HOUR_ANGLE_AMP


        """
        Limiting magnitude
        """
        if limiting_magnitude:
            self.limiting_magnitude=limiting_magnitude
        else:
            self.limiting_magnitude=None

        """
        Minimal angular distance to the Moon
        """
        if moon_angdist_min is not None:
            if moon_angdist_min>MOON_ANGDIST_MIN: # user is not allowed to do funny things
                self.moon_angdist_min=moon_angdist_min
        else:
            self.moon_angdist_min = MOON_ANGDIST_MIN # degrees    


        """
        ------------------------------------
        Time dependent variables
        ------------------------------------
        """

        """
        Determine local sidereal time
        """
        self.utc = Time(Time.now(), format='iso', scale='utc')
        self.local_sidereal_time = self.utc.sidereal_time('mean', longitude=self.lon).value

        """
        Current telescope position
        """
        if ra_current and dec_current:
            self.ra_current=ra_current
            self.dec_current=dec_current
        else:
            # todo: at what coordinates is telescope parked?
            self.ra_current=self.local_sidereal_time*15.0
            self.dec_current=-30.0


        """
        Moon
        """
        self.moon = get_moon(self.utc)
        # Astropy Moon coordinates agree with Stellarium within a degree. This is good enough for the Scheduler.

        # User defined settings
        # Manually enter desired priority of the field. If None, tiles with highest priorities will be selected automatically.
        self.desired_priority=desired_priority
        self.minimal_priority=minimal_priority
        # TODO: Error check if value entered is valid
        
        # Processing time (time per tile)
        if time_per_tile:
            self.time_per_tile=time_per_tile
        else:
            self.time_per_tile=TIME_PER_TILE


    def __str__(self):
        string="""
        __str__:
        TODO=True
        """
        return string

    def __repr__(self):
        string="""
        __repr__:
        TODO=True
        """
        return string

    def init_best_tiles_to_observe(self, local_sidereal_time=None, moon=None, observatory=None, sunset=None, ra_current=None, dec_current=None):
        """
        Init ObsTiles. At the beginning all tiles are assumed good to observe, then we throw away those not appropriate at the moment.
        """
        #~ # TODO: insert current telescope position in order to estimate slew time
        
        if local_sidereal_time is None:
            local_sidereal_time=self.local_sidereal_time
        if moon is None:
            moon=self.moon
        if ra_current is None:
            ra_current=self.ra_current
        if dec_current is None:
            dec_current=self.dec_current

        # Init only those that are within HOUR_ANGLE_AMP
        tiles = self.select_only_tiles_within_hour_angle_amp()

        # All candidate tiles: exclude those that are not visible; we need this to determine density weights
        self.select_only_tiles_within_hour_angle_amp_all_candidate_tiles()

        result=[ObsTile(tp=x, lat=self.lat, local_sidereal_time=local_sidereal_time, moon=moon, observatory=observatory, sunset=sunset, ra_current=ra_current, dec_current=dec_current, max_priority=self.max_priority, tile_density_radius=self.tile_density_radius, observed_tiles=self.observed_tiles, altitude_low_fraction=self.altitude_low_fraction) for x in tiles]

        return result

    def select_only_tiles_within_hour_angle_amp(self):
        """
        Exclude tiles that are not visible right now. Keep only those close to the local meridian (H_amp away from the local meridian at most).
        """
        S=self.local_sidereal_time
        H_amp = self.hour_angle_amp
        
        ra_min = S - H_amp
        if ra_min<0.0:
            ra_min=24.0-ra_min
        ra_min *= 15.0
        
        ra_max = S + H_amp
        if ra_max>24.0:
            ra_max=ra_max-24.0
        ra_max *= 15.0

        if ra_min<ra_max:
            b=[x for x in self.tiles if x.ra>ra_min and x.ra<ra_max]
        elif ra_min>ra_max:
            b1=[x for x in self.tiles if x.ra>ra_min]
            b2=[x for x in self.tiles if x.ra<ra_max]
            b=b1+b2

        return b

    def select_only_tiles_within_hour_angle_amp_all_candidate_tiles(self):
        """
        Exclude tiles in the 'all hemisphere candidate tiles list' that are not observable this night. This speeds up the tile surface density determination.
        """
        sunset_lst=Time(self.sun_set).utc.sidereal_time('mean', longitude=self.lon).value
        sunrise_lst=Time(self.sun_rise).utc.sidereal_time('mean', longitude=self.lon).value
        
        H_amp = 0.25
        
        ra_min = sunset_lst - H_amp
        if ra_min<0.0:
            ra_min=24.0-ra_min
        ra_min *= 15.0
        
        ra_max = sunrise_lst + H_amp
        if ra_max>24.0:
            ra_max=ra_max-24.0
        ra_max *= 15.0

        if ra_min<ra_max:
            new_dict={}
            for k, v in self.tiles_mag_range.iteritems():
                b=[x for x in v if x.ra>ra_min and x.ra<ra_max]
                new_dict[k]=b
            self.tiles_mag_range=new_dict
        elif ra_min>ra_max:
            new_dict={}
            for k, v in self.tiles_mag_range.iteritems():
                b=[x for x in v if x.ra>ra_min]
                new_dict[k]=b
                
            for k, v in self.tiles_mag_range.iteritems():
                b=[x for x in v if x.ra<ra_max]
                b0=new_dict[k]
                new_dict[k]=b0+b

            self.tiles_mag_range=new_dict

    #~ @profile
    def find_the_best_tile_to_observe_now(self): # Run this to find the best tile to observe now.
        """
        
        """
        self.best_tiles_to_observe_now=self.init_best_tiles_to_observe()
        best_tiles = self.find_the_best_tile_to_observe()
        return best_tiles
  
    #~ @profile    
    def find_the_best_tile_to_observe(self): # A combination of different methods. Used by both: find_the_best_tile_to_observe_now and make_list_of_best_tiles_through_the_night
        """
        This is a master function. Use multiple methods to find a best tile to be observed now.
        First, all tiles are assumed to be appropriate to observe. Then we exclude tiles that are not appropriate at the moment.
        """
       
        # Exclude tiles already observed. Only tiles from the input tiling file are considered + tiles already selected in the all-night schedule.
        self.exclude_tiles_already_observed()
        
        # Position restrictions
        self.lower_RA_limit()
        self.upper_RA_limit()
        self.lower_altitude_limit() # Tiles visible on this day
        self.exclude_zenith()
        self.exclude_tiles_too_close_to_the_moon()
        
        # Magnitude restrictions
        self.exclude_tiles_below_limiting_magnitude() # user defined
        
        # Priorities
        # Determine weights for candidate tiles:
        for x in self.best_tiles_to_observe_now:
            x.weighting(tiles_mag_range=self.tiles_mag_range)
        
        b = sorted(self.best_tiles_to_observe_now, key=lambda y: y.weight, reverse=True)
        self.best_tiles_to_observe_now=b
        
        #~ self.find_tiles_closest_to_local_meridian() # TODO: tile_priority overrides this sorting
        #~ self.tile_priority()
        
        # Get data
        best_tile=self.best_tiles_to_observe_now
        return best_tile

    #~ @profile
    def make_list_of_best_tiles_through_the_night(self, date=None, time=None):
        """
        Make a list of best tiles observable through the night.
        
        Output: observing_plan.txt
        # observing_ideal observing_start observing_stop fieldID path_to_config_file
        1030 1000 1100 fieldID /observers_files/taipan/YYYYMMDD/tile_pk_HHMMSS.obs_config.json
        
        observing_ideal = meridian transit time
        observing_start, observing_stop: observing_ideal +/- dt, dt is determined using weights
        
        Should times be given in UT?
        What is the json file (e.g. list of stars with coordinates etc.?)
        
        TODO: What is ObsConfig file?
        """     
        # Observatory
        #~ observatory = Observer.at_site("Anglo-Australian Observatory") # TODO: enter LAT and LON coordinates
        
        #~ # Determine sunset and sunrise times
        #~ datenow=datetime.datetime.now().date()
        #~ date='%d-%02d-%02d'%(datenow.year, datenow.month, datenow.day)
        #~ time = Time('%s 23:30:00'%date)
        
        #~ sun_set = observatory.sun_set_time(time, which="previous").datetime
        #~ sun_rise = observatory.sun_rise_time(time, which="previous").datetime # previous. This is correct.
        sun_set=self.sun_set
        sun_rise=self.sun_rise
        
        sunset=self.observatory.datetime_to_astropy_time(sun_set)
        
        f=open('observing_plan.dat', 'wb')

        # UTC times
        times = [sun_set + datetime.timedelta(minutes=i*self.time_per_tile) for i in range(1, 100) if sun_set + datetime.timedelta(minutes=i*self.time_per_tile)<=sun_rise]
        
        # Convert UTC times to LST
        times_lst = [Time(t).utc.sidereal_time('mean', longitude=self.lon).value for t in times]

        selected_tiles=[]
        count=1
        for t, lst in zip(times, times_lst):            
            #~ utc = Time('%d-%02d-%02d %02d:%02d:%02d'%(t.year, t.month, t.day, t.hour, t.minute, t.second), format='iso', scale='utc')
            utc = observatory.datetime_to_astropy_time(t)
            moon = get_moon(utc)

            # TODO: Where are ra_current and dec_current updated? Jeeves needs to tell us where the telescope is (or we take coordinates of the previously selected tile; however, at the beginning of the night we need to know where the telescope is, or when we take over from Taipan, or if for some reason telescope is slewed manually etc.).
            try:
                ra_current=best_tile.TaipanTile.ra
                dec_current=best_tile.TaipanTile.dec
            except:
                ra_current=self.ra_current
                dec_current=self.dec_current

            self.local_sidereal_time=lst # TODO: check if this violates any other things. Why cant I insert LST to init_best_tiles...??
            self.best_tiles_to_observe_now=self.init_best_tiles_to_observe(local_sidereal_time=lst, moon=moon, observatory=observatory, sunset=sunset, ra_current=ra_current, dec_current=dec_current) # TODO: why sunset, but I skip sunrise?
            
            
            # Find best tile for time t
            tls=self.find_the_best_tile_to_observe()
            
            # Tiles cannot be selected twice
            do_selection=True
            i=0
            while do_selection:
                best_tile=tls[i]
                if best_tile.TaipanTile.field_id not in selected_tiles:
                    selected_tiles.append(best_tile.TaipanTile.field_id)
                    break
                else:
                    i+=1
            
            # TODO: among the tiles with best weights, select one closest to local meridian!!!
            
            # Update list of observed tiles
            # TODO: LATER update the code: wait for Jeeves to confirm that tile has been observed successfully
            self.observed_tile_ids.append(int(best_tile.TaipanTile.field_id))
            mag_range=(float(best_tile.TaipanTile.mag_min), float(best_tile.TaipanTile.mag_max))
            try:
                obs_tiles_tmp=self.observed_tiles[mag_range]
                obs_tiles_tmp.append(best_tile.TaipanTile)
            except:
                obs_tiles_tmp=[best_tile.TaipanTile]
            self.observed_tiles[mag_range]=obs_tiles_tmp

            print count, len(times), t, lst*15.0
            print 'LST=%s'%(('%.11f'%lst).rjust(14)), best_tile #, best_tile.meridian_transit_time.datetime
            

            # Print out the data
            H_amp = best_tile.estimate_best_time_interval_to_observe_tile()
            # TODO: check if this times are during the night, not e.g. just before sunset or just after sunrise
            observing_start = t - datetime.timedelta(hours=H_amp)
            observing_stop = t + datetime.timedelta(hours=H_amp)
            observing_ideal = Time(t - datetime.timedelta(hours=best_tile.hour_angle)).utc.sidereal_time('mean', longitude=self.lon).value # Do I insert time NOW or time of meridian crossing?
            
            
            """
            Print output
            """
            line='%02d%02d %02d%02d %02d%02d %05d /observers_files/funnelweb/YYYYMMDD/%05d_HHMMSS.obs_config.json'%(t.hour, t.minute, observing_start.hour, observing_start.minute, observing_stop.hour, observing_stop.minute, best_tile.TaipanTile.field_id, best_tile.TaipanTile.field_id)
            print line # TODO: change t. to observing_ideal
            print
            # TODO: what happens with observing_ideal for tiles at ALT=90? Because there is a limit at 85 degrees.
            f.write(line+'\n')
        
            count+=1
        f.close()

    def exclude_tiles_already_observed(self):
        """
        Exclude tiles with tile IDs in the list of tiles already observed.
        """
        if len(self.observed_tile_ids)>0:
            good=[x for x in self.best_tiles_to_observe_now if x.TaipanTile.field_id not in self.observed_tile_ids]
            self.best_tiles_to_observe_now=good
        else:
            pass
    

    def lower_altitude_limit(self):
        """
        Find tiles with altitude high enough to be observable.
        """
        visible_tiles=[]
        for x in self.best_tiles_to_observe_now:
            if x.alt>self.alt_min:
                visible_tiles.append(x)
        self.best_tiles_to_observe_now=visible_tiles

    def exclude_zenith(self):
        """
        Exclude zenith due to technical obstacles.
        """
        visible_tiles=[]
        for x in self.best_tiles_to_observe_now:
            if x.alt<self.alt_max:
                visible_tiles.append(x)
        self.best_tiles_to_observe_now=visible_tiles

    def lower_RA_limit(self):
        """
        If self.ra_min is not None, take only tiles with centre RA>=ra_min
        """
        if self.ra_min:
            good=[x for x in self.best_tiles_to_observe_now if x.TaipanTile.ra>=self.ra_min]
            self.best_tiles_to_observe_now=good
            if len(good)<1:
                print 'WARNING: There is no tiles with RA>=%f.'%self.ra_min
        else:
            pass

    def upper_RA_limit(self):
        """
        If self.ra_max is not None, take only tiles with centre RA<=ra_min
        """
        if self.ra_max:
            good=[x for x in self.best_tiles_to_observe_now if x.TaipanTile.ra<=self.ra_max]
            self.best_tiles_to_observe_now=good
            if len(good)<1:
                print 'WARNING: There is no tiles with RA<=%f.'%self.ra_max
        else:
            pass

        
    def find_tiles_closest_to_local_meridian(self):
        """
        Sort tiles according to their hour_angle. Tiles closest to local meridian are listed first.
        """
        tiles=sorted(self.best_tiles_to_observe_now, key=lambda x: np.abs(x.hour_angle))
        self.best_tiles_to_observe_now=tiles
            
    def exclude_tiles_too_close_to_the_moon(self):
        """
        Exclude tiles closer than self.moon_angdist_min from the Moon.
        """
        good_tiles=[x for x in self.best_tiles_to_observe_now if x.angular_moon_distance>self.moon_angdist_min]
        self.best_tiles_to_observe_now=good_tiles    
    
    def exclude_tiles_below_limiting_magnitude(self):
        """
        Exclude tiles within magnitude ranges that include stars fainter than the limiting magnitude.
        """
        if self.limiting_magnitude:
            good_tiles=[x for x in self.best_tiles_to_observe_now if x.TaipanTile.mag_max<=self.limiting_magnitude]
            self.best_tiles_to_observe_now=good_tiles
        else:
            pass
        
    def weather_conditions(self):
        """
        Define limiting magnitude regarding the weather conditions.

        Parameters
        ----------
        seeing:
        
        Return:
        ----------        
        limiting_magnitude: float
            Limiting magnitude for given weather conditions.
        
        
        
        
        
        WHAT is a relation between seeing and limiting magnitude?
        
        sky transparency (--> limiting magnitude)        
        
        
        """
        todo=True
        
        
        #~ if self.weather_data:
            # seeing=?
            
            
            #~ self.limiting_magnitude=TODO
        
        
            
    def tile_priority(self):
        # Tile priority: summing up the priorities of the TaipanTargets within the tile.
        if self.minimal_priority:
            good=[x for x in self.best_tiles_to_observe_now if x.TaipanTile.priority>=self.minimal_priority]
            if len(good)<1:
                print 'WARNING: There is no tiles with desired minimal_priority.'
                self.best_tiles_to_observe_now=good
            else:
                good=sorted(good, key=lambda x: x.TaipanTile.priority, reverse=True)
        else:
            # Choose the highest priority tiles
            good=sorted(self.best_tiles_to_observe_now, key=lambda x: x.TaipanTile.priority, reverse=True)
        self.best_tiles_to_observe_now=good    
        # If there is no tiles with minimal_priority, select the next one


    def manage_observed_tiles(self):
        tiles_dict={x.field_id: x for x in self.tiles}

        obs_tiles_dict = defaultdict(list)
        if self.observed_tiles_filename:
            #~ try:
            observed_tiles=np.loadtxt(self.observed_tiles_filename, comments='#')
            self.observed_tile_ids=[int(x) for x in observed_tiles] # a list of integers (IDs)

            # Split into magnitude ranges
            for t in self.observed_tile_ids:
                x=tiles_dict[t]
                obs_tiles_dict[(float(x.mag_min), float(x.mag_max))].append(x)
            obs_tile_coo2={k: v for k, v in obs_tiles_dict.iteritems()} # because obs_tile_coo is defaultdict (creates new list in the dict if a key that does not exist yet is called)
            self.observed_tiles=obs_tile_coo2
            #~ except:
                #~ self.observed_tile_ids=[]
                #~ self.observed_tiles={}
                #~ print 'WARNING: File with tile IDs already observed cannot be read.'
        else:
            self.observed_tile_ids=[]        


    def print_selected_tile_to_json(self):
        """
        Generate dictionary of output data and write to a json file.
        """
        # Generate dictionary
        t = self.best_tiles_to_observe_now[0]
        data={
        'tile_id': t.TaipanTile.field_id
        }
        #~ 'TaipanTile': t.TaipanTile # Class is not serializable
        
        # Write
        # Each time add timestamp to json file. Is this a good idea? Because then Jeeves has to search for the latest filename each time.
        timestamp=self.utc.value.replace(' ', '--')
        filename='selected_tile_%s.json'%timestamp
        with open(filename, 'w') as outfile:  
            json.dump(data, outfile)    
        print '%s created.'%filename

class ObsTile():
    """
    Observational parameters of a tile. This class makes no observational decisions, it only determines parameters.
    """
    #~ @profile
    def __init__(self, tp=None, lat=None, local_sidereal_time=None, moon=None, observatory=None, sunset=None, ra_current=None, dec_current=None, max_priority=None, tile_density_radius=None, local_surface_area=None, tile_density_global=None, observed_tiles=None, altitude_low_fraction=None):
        """
        Parameters
        ----------        
        TaipanTile:
        ra, dec: tile coordinates, degrees
        lat: observer's latitude, degrees
        local_sidereal_time: Local sidereal time, hours
        moon: astropy moon object
        observatory: astroplan observatory object
        sunset: astropy Time object: sunset time
        
        hour_angle: Hour angle of a tile at time local_sidereal_time, hours
        alt: altitude of a center of a tile for a given hour_angle, degrees
        alt_max: maximal altitude of a center of a tile (in upper culmination), degrees
        alt_diff: 
        angular_moon_distance: Angular distance between the tile and the Moon, degrees
        """
        self.TaipanTile=tp
        self.ra=tp.ra
        self.dec=tp.dec
        self.lat=lat
        self.ra_current=ra_current
        self.dec_current=dec_current
        self.altitude_low_fraction=altitude_low_fraction
        self.max_priority=max_priority
        self.tile_density_radius=tile_density_radius
        self.observed_tiles=observed_tiles # ACTUALLY not a good idea as it takes a lot of RAM eventually over time   
        
        self.local_sidereal_time=local_sidereal_time
        self.moon=moon
        self.observatory=observatory
        self.sunset=sunset

        """
        Compute observational parameters
        """
        self.hour_angle=self.determine_hour_angle()
        self.alt=self.altitude_of_an_object_in_the_sky()
        
        # These params could be set later, only for visible tiles
        self.alt_max=self.max_altitude_of_an_object_in_the_sky()
        self.angular_moon_distance=self.distance_between_two_points_in_the_sky(alpha1=self.ra, delta1=self.dec, alpha2=self.moon.ra.value, delta2=self.moon.dec.value)


    @property
    def local_sidereal_time(self):
        return self.local_sidereal_time

    @local_sidereal_time.setter
    def local_sidereal_time(self, value):    
        self.local_sidereal_time = value
        
    def __str__(self):
        string = 'TP TILE %s: RA=%s, Dec=%s, Ranking=%s, w=%s, Altitude=%s, H=%s, Moon_dist=%s, mag_max=%s' % (('%d'%self.TaipanTile.field_id).rjust(5), ('%3.1f'%self.TaipanTile.ra).rjust(5), ('%2.1f'%self.TaipanTile.dec).rjust(5), ('%d'%self.TaipanTile.priority).rjust(5), ('%2.4f'%self.weight).rjust(8), ('%d'%self.alt).rjust(2), ('%.2f'%self.hour_angle).rjust(6), ('%d'%self.angular_moon_distance).rjust(3), ('%d'%self.TaipanTile.mag_max).rjust(2))
        return string

    #~ def __repr__(self):
        #~ string = 'TP TILE %d: RA=%3.1f, Dec=%2.1f, Ranking=%d, Altitude=%d, %d, %d, H=%.2f, Moon_dist=%d, mag_max=%d' % (self.TaipanTile.field_id, self.TaipanTile.ra, self.TaipanTile.dec, self.TaipanTile.priority, self.alt, self.alt_max, self.alt_diff, self.hour_angle, self.angular_moon_distance, self.TaipanTile.mag_max)
        #~ return string

    #~ @profile
    def distance_between_two_points_in_the_sky(self, alpha1=None, delta1=None, alpha2=None, delta2=None):
        """
        Determine the distance between two points in the sky.
        
        Parameters
        ----------
        alpha1, delta1: float, degrees
            RA and Dec for object 1
        alpha2, delta2: float, degrees
            RA and Dec for object 2
        
        Output
        ----------
        A: float, degrees
            Distance between two points in the sky.
        """
        a1=np.deg2rad(alpha1)
        d1=np.deg2rad(delta1)
        a2=np.deg2rad(alpha2)
        d2=np.deg2rad(delta2)
        
        cos_A = np.sin(d1)*np.sin(d2) + np.cos(d1)*np.cos(d2)*np.cos(a1-a2)
        A=np.arccos(cos_A) # [0, 180] in radians
        A=np.rad2deg(A)
        return A # degrees

    #~ @profile
    def determine_azimuth(self, ra=None, dec=None, alt=None, H=None):
        """
        Azimuth for the tile.
        """
        #~ alpha=np.deg2rad(ra)
        # TODO: remove ra.
        delta=np.deg2rad(dec)
        h=np.deg2rad(alt)
        phi=np.deg2rad(self.lat)
        hour_angle = np.deg2rad(H*15.0)
        
        cosA = (np.sin(delta) - np.sin(h)*np.sin(phi)) / (np.cos(h)*np.cos(phi))
        sinA = - np.sin(hour_angle) * np.cos(delta) / np.cos(h)
        
        A = math.atan2(sinA, cosA)
        A = np.rad2deg(A)
        
        #~ A=np.arccos(cosA)
        #~ A=np.rad2deg(A)
        
        #~ H=np.deg2rad(H*15.0)
        #~ if np.sin(H)>0:
            #~ A=360.0-A
    
            
        return A

    def determine_hour_angle(self, ra=None):
        """
        Determine hour angle of a tile.
        
        Output
        ----------
        H: float, hours
            Hour angle of the tile.        
        """
        if ra:
            H = self.local_sidereal_time - ra/15.0
        else:
            H = self.local_sidereal_time - self.ra/15.0
        if H>12:
            H=24.0-H
        if H<-12:
            H=24.0+H
        # TODO: check again why does this happen
        return H

    def altitude_of_an_object_in_the_sky(self, hour_angle=None, dec=None):
        """
        Determine altitude of a tile above horizon.
        
        Output
        ----------
        h: float, degrees
            Altitute of the tile above horizon.        
        """
        # No need for atmospheric refraction correction.
        # Disagrees with Stellarium for about 5 degrees (Stellarium is using apparent altitude, but 5 degrees difference was for a star in zenith!!)
        
        if hour_angle and dec:
            hour_angle=np.deg2rad(hour_angle*15.0)
            dec=np.deg2rad(dec)
        else:
            hour_angle=np.deg2rad(self.hour_angle*15.0)
            dec=np.deg2rad(self.dec)
        
        lat=np.deg2rad(self.lat)
        sin_h = np.cos(hour_angle)*np.cos(dec)*np.cos(lat) + np.sin(dec)*np.sin(lat)
        h=np.arcsin(sin_h)
        h=np.rad2deg(h)
        return h

    def max_altitude_of_an_object_in_the_sky(self):
        """
        Determine maximal altitude of a tile above horizon.
        
        Output
        ----------
        h: float, degrees
            Maximal altitute of the tile above horizon.        
        """
        dec=np.deg2rad(self.dec)
        lat=np.deg2rad(self.lat)
        sin_h = np.cos(dec-lat)
        h=np.arcsin(sin_h)
        h=np.rad2deg(h)
        return h

        

    def estimate_best_time_interval_to_observe_tile(self):
        """
        Determine hour angle amplitude to estimate time when observing is still acceptable
        """
        dec=np.deg2rad(self.dec)
        lat=np.deg2rad(self.lat)

        h_good_fraction = self.altitude_low_fraction
        h_meridian = self.alt_max
        h_good_low = h_meridian * h_good_fraction
        h_good_low = np.deg2rad(h_good_low)
        
        cosH = (np.sin(h_good_low) - np.sin(lat)*np.sin(dec)) / (np.cos(lat)*np.cos(dec))
        #~ print h_meridian, h_meridian * h_good_fraction, self.dec, self.lat, cosH
        try:
            H = np.arccos(cosH)
            H = np.rad2deg(H)
            H = np.abs(H)
            H = H / 15.0 # hours
        except:
            return 5000000.0 # TODO: how to treat |cosH|>1??
        return H

            
    #~ @profile
    def weighting(self, tiles_mag_range=None):
        """
        Weighting between H (hour angle), Ranking (priority) and slew time.
        """
        w_altitude = self.weighting_altitude() # [0, 1]
        w_slew_time = self.weighting_slew_time() # [0, 1]
        w_density = self.weighting_field_density(tiles_mag_range=tiles_mag_range) # [0, 1]
        
        w_ranking = float(self.TaipanTile.priority) / float(self.max_priority) # [0, 1]
        # Some tiles have ranking equal to 0. So we set probability to 0.5:
        if w_ranking<1e-12:
            w_ranking=0.5
        
        w = w_ranking * w_altitude * w_slew_time * w_density * 1000.0      
        self.weight = w
        
    def weighting_altitude(self):
        """
        Return altitude_current / altitude_at_meridian.
        """
        H=self.hour_angle
        dec=self.TaipanTile.dec
        alt=self.alt
        alt_max=self.alt_max # altitude at local meridian
        
        w = float(alt)/float(alt_max)
        
        return w

    #~ @profile
    def weighting_slew_time(self):
        """
        Slew time function: a maximum of angular distance and difference in azimuth.
        """       
        # Current position:
        ra1=self.ra_current
        dec1=self.dec_current
        
        # Next position:
        ra2=self.TaipanTile.ra
        dec2=self.TaipanTile.dec
        
        angle=self.distance_between_two_points_in_the_sky(alpha1=ra1, delta1=dec1, alpha2=ra2, delta2=dec2)
        if angle>180.0:
			angle=360.0-angle
        
        # Azimuth      
        H1=self.determine_hour_angle(ra=ra1)
        alt1=self.altitude_of_an_object_in_the_sky(hour_angle=H1, dec=dec1)
        az1=self.determine_azimuth(ra=ra1, dec=dec1, alt=alt1, H=H1)
        
        az2=self.determine_azimuth(ra=ra2, dec=dec2, alt=self.alt, H=self.hour_angle)
        
        az=np.abs(az2-az1)
        if az>180.0:
			az=360.0-az
        
          
        # If slew time is less than e.g. 60s (approximate readout time and minimum starbug reconfiguration) then ignore slew time.
        # TODO: how do I know relation between the angle and slew time?

        m=np.max([angle, az])
        result=(180.0 - m) / 180.0
        #~ result=((180.0 - m) / 180.0)**4
        #~ result=np.cos(m)
        result=np.exp(-result)
        #~ result=np.exp(-m)
        
        #~ print 'azimuth', ra1, ra2, dec1, dec2, az1, az2, az, m, result

        return result

    #~ @profile
    def weighting_field_density(self, tiles_mag_range=None):
        """
        Determine local field density (for a particular magnitude range)
        """
        ra=self.TaipanTile.ra # deg
        dec=self.TaipanTile.dec # deg
        
        mag_range=(float(self.TaipanTile.mag_min), float(self.TaipanTile.mag_max))

        # Number of observed tiles within the tile_density_radius
        try:
            observed_tiles=self.observed_tiles[mag_range]
        except:
            # No fields were observed yet
            return 1.0
        n=0
        for x in observed_tiles: # TODO: make hour_angle exclusion loop (because after time number of observed tiles is going to grow (or perhaps not because new tiling will be generated each month)
            if np.abs(ra-x.ra)<self.tile_density_radius and np.abs(dec-x.dec)<self.tile_density_radius:
                d=self.distance_between_two_points_in_the_sky(alpha1=ra, delta1=dec, alpha2=x.ra, delta2=x.dec)
                if d<self.tile_density_radius:
                    n+=1
        n_observed=float(n)


        # All candidate tiles from the tiling code within tile_density_radius
        n=0
        for x in tiles_mag_range[mag_range]:
            if np.abs(ra-x.ra)<self.tile_density_radius and np.abs(dec-x.dec)<self.tile_density_radius:
                d=self.distance_between_two_points_in_the_sky(alpha1=ra, delta1=dec, alpha2=x.ra, delta2=x.dec)
                if d<self.tile_density_radius:
                    n+=1
        n_total=float(n)

        if n<0.5:
            return 0.0 # apparently out of the range

        weight = 1.0 - n_observed / n_total

        return weight
    

"""
-------------------
Tests
-------------------
All the possible situations:
- only part of the sky is clear

"""

def run_scheduler(tiling_filename, observed_tiles_filename):
    """
    Run scheduler for testing purposes.
    """
    # Basic example with no limitations other than altitude and Moon distance
    s=Scheduler(tiling_filename=tiling_filename, observed_tiles_filename=observed_tiles_filename)

    # Example with limitations
    #~ s=Scheduler(tiling_filename=tiling_filename, observed_tiles_filename=observed_tiles_filename, alt_min=20.0, alt_max=50.0, moon_angdist_min=20.0, ra_min=200, ra_max=250, limiting_magnitude=9)
    

    t=s.find_the_best_tile_to_observe_now()
    t0=t[0]
    print 'Best tile:', t0
    s.print_selected_tile_to_json()
    
    for x in t[:10]:
        print x    


def observing_plan(tiling_filename, observed_tiles_filename, date=None, time=None):
    """
    Run observing plan for testing purposes.
    """

    s=Scheduler(tiling_filename=tiling_filename, observed_tiles_filename=observed_tiles_filename)
    s.make_list_of_best_tiles_through_the_night(date=date, time=time)


def test_tile_distribution_in_the_sky(filename):
    """
    Plot RA, Dec of all the candidate tiles from the tiling file.
    """
    fl = open(filename,'rb')
    tiles = pickle.load(fl)[0]
    fl.close()
    print 'Number of tiles:', len(tiles)
    
    c=np.array([[x.ra/15.0, x.dec] for x in tiles])
    
    import matplotlib.pylab as plt
    fig=plt.figure()
    ax=fig.add_subplot(111)
    ax.scatter(c[:,0], c[:,1], s=5)
    plt.show()

def test_read_json_file(filename):
    """
    Check if json file is readable.
    """
    with open(filename) as json_file:  
        data = json.load(json_file)
    print data

     
            
if __name__ == "__main__":
    #~ dir = '/Users/mireland/Google Drive/FunnelWeb/TargetSelection/tiling_results/'
    #~ tiling_filename=dir + '171308_1647_fw_tiling.pkl'
    
    tiling_filename='171308_1647_fw_tiling.pkl'
    observed_tiles_filename='%s_observed_tiles.txt'%tiling_filename[:-4]

    """
    Run Scheduler
    """
    #~ run_scheduler(tiling_filename, observed_tiles_filename)
    
    observing_plan(tiling_filename, observed_tiles_filename, date='2017-10-23', time='02:42:42')

    
    """
    Tests
    """
    #~ test_tile_distribution_in_the_sky(tiling_filename)
    #~ test_read_json_file('selected_tile_2017-10-09--01:42:30.379.json')
    
    
    #~ import pdb
    #~ pdb.set_trace()
    
    #~ reload(fwtl)
    #~ fwtiler = FWTiler(...)
    #~ %run -i script.py
