"""
FunnelWeb: Decide which tile to observe next, based on sidereal time and observing conditions (weather, seeing etc.).
"""

# Should this code select only one tile to be observe next, or a few best candidates?

# Assumption: none of the tiles from the input file have not been observed yet. If Scheduler is run muptiple times during the night make sure you exclude tiles that have already been observed this night.
# Tiling will be run about once per month anyway so there should be a list of observed tiles.



import numpy as np
import random
import pickle
import datetime

from astropy.time import Time
from astropy.coordinates import get_moon
from astropy.coordinates.earth import EarthLocation
import astropy.units as u
from astroplan import Observer

# Taipan
import taipan # written for python2
import core as tp
# Have to run the code in python 2. Astropy requires numpy>1.9.1. How to do that? It doesn't work with pip


class Scheduler():
	"""
	Schedule FunnelWeb tile observations.
	"""
	def __init__(self, tiling_filename=None, observed_tiles_filename=None, weather_data_filename=None, alt_min=None, alt_max=None, ra_min=None, ra_max=None, moon_angdist_min=None, lat=None, lon=None, desired_priority=None, minimal_priority=None, processing_time=300.0, limiting_magnitude=None):
		"""
        Parameters
        ----------
		tiling_filename: string
			A pickle data filename of tiles generated by the tiling code.
		observed_tiles_filename: string
			A file with a list of tile IDs (a list of integers) that have already been observed. TODO: MAKE SURE THAT TILE IDs ARE UNIQUE.
		weather_data_filename: string
			Filename of the weather data.
		alt_min: float, degrees
			Minimal allowed altitude of a tile above the horizon. Default: 30.0.
		alt_max: float, degrees
			Maximal allowed altitude of a tile. (Avoid observing zenith). Default: 70.0.
		ra_min, ra_max: float, degrees
			Limit tiles within certain RA limits (e.g. when only part of the sky is clear).
		moon_angdist_min: float, degrees
			Angular distance between the Moon and the tile. Default: 20.0.
		lat, lon: float, degrees
			Observer's latitude and longitude. Default: lat=-31.2749, lon=149.0685 (Siding Spring).
		desired_priority: float
			Desired priority to be observed.
		minimal_priority: float
			User defined minimal tile priority to be observed.
		processing_time: float, seconds
			Total time spend per tile (slewing, exposure, calibration etc.). Default: 300.0.
		limiting_magnitude: float
			Magnitude of a faintest star to be observed. Default: None.
		"""
		
		"""
		Read the data
		"""
		if tiling_filename:
			print 'Reading data...'
			fl = open(tiling_filename,'rb')
			data = pickle.load(fl)
			fl.close()
			
			self.tiles = data[0]
			self.settings = data[2]
			
			print 'Number of tiles:', len(self.tiles)
		else:
			print 'tiling_filename is None.'
			exit(0)
		
		if observed_tiles_filename:
			try:
				observed_tile_ids=np.loadtxt(observed_tiles_filename)
				self.observed_tile_ids=observed_tile_ids # a list of integers (IDs)
			except:
				self.observed_tile_ids=[]
				print 'WARNING: File with tile IDs already observed cannot be read.'
		else:
			self.observed_tile_ids=[]
		
		
		if weather_data_filename:
			self.weather_data=np.loadtxt(weather_data_filename) # STRING!!
		else:
			self.weather_data=None
		
		"""
		Determine field_id and priority.
		Calculate_the_score should remain here.
		"""
		# TODO: Later remove field_id as tile_id will be already available in the TaipanTiles.
		tiles2=[]
		for tile_id, x in enumerate(self.tiles):
			x.field_id=tile_id
			x.priority=x.calculate_tile_score(method=self.settings['ranking_method'], disqualify_below_min=self.settings['disqualify_below_min'], combined_weight=self.settings['combined_weight'], exp_base=self.settings['exp_base'])
			tiles2.append(x)
		self.tiles=tiles2
		

		"""
		Observer's coordinates
		# Siding Spring Observatory
		"""
		# TODO: this data is automatic result from Google. Check if it is correct
		if lat:
			self.lat=lat
		else:
			self.lat=-31.2749 # deg South
		if lon:
			self.lon=lon
		else:
			self.lon=149.0685 # deg East

		#~ observatory=EarthLocation('Anglo-Australian Observatory')
		observatory = Observer(at_site="Anglo-Australian Observatory")
		sun_set = apo.sun_set_time(time, which="next")


		"""
		Minimal altitude of a tile above the horizon.
		"""
		ALT_MIN=30.0
		if alt_min:
			if alt_min>ALT_MIN:
				self.alt_min=alt_min
			else: # user is not allowed to do funny things
				self.alt_min=ALT_MIN
				print 'WARNING: Minimal altitude too low. Set to %g degrees.'%ALT_MIN
		else:
			self.alt_min = ALT_MIN # degrees


		"""
		Maximal tile altitude valid to observe - due to technical obstacles (cannot observe zenith). ???? DO WE NEED THIS?
		"""
		ALT_MAX=70.0
		if alt_max:
			if alt_max<ALT_MAX:
				self.alt_max=alt_max
			else: # user is not allowed to do funny things
				self.alt_max=ALT_MAX
				print 'WARNING: Maximal altitude limit too high. Set to %g degrees.'%ALT_MAX
		else:
			self.alt_max = ALT_MAX # degrees


		"""
		Limit RA in case of partly cloudy sky.
		"""
		if ra_min:
			if ra_min>1e-10 and ra_min<360.0+1e-10:
				self.ra_min=ra_min
			else:
				self.ra_min=None
				print 'WARNING: You must enter 0 < ra_min < 360.'
		if ra_max:
			if ra_max>1e-10 and ra_max<360.0+1e-10:
				self.ra_max=ra_max
			else:
				self.ra_max=None
				print 'WARNING: You must enter 0 < ra_max < 360.'

		if self.ra_min and self.ra_max:
			if self.ra_min>self.ra_max or np.abs(self.ra_min-self.ra_max)<1e-6:
				print 'WARNING: '



		"""
		Limiting magnitude
		"""
		if limiting_magnitude:
			self.limiting_magnitude=limiting_magnitude
		else:
			self.limiting_magnitude=None

		"""
		Minimal angular distance to the Moon
		"""
		if moon_angdist_min is not None:
			if moon_angdist_min>15.0: # user is not allowed to do funny things
				self.moon_angdist_min=moon_angdist_min
		else:
			self.moon_angdist_min = 20.0 # degrees	


		"""
		Determine local sidereal time
		"""
		self.utc = Time(Time.now(), format='iso', scale='utc')
		self.local_sidereal_time = self.utc.sidereal_time('mean', longitude=self.lon).value


		"""
		Moon
		"""
		self.moon = get_moon(self.utc)
		# Astropy Moon coordinates agree with Stellarium within a degree. This is good enough for the Scheduler.
		#~ exit(0)


		# User defined settings
		# Manually enter desired priority of the field. If None, tiles with highest priorities will be selected automatically.
		self.desired_priority=desired_priority
		self.minimal_priority=minimal_priority
		# TODO: Error check if value entered is valid
		
		# List of tiles per entire night
		self.processing_time=processing_time


		# At the beginning all tiles are assumed good to observe, then we throw away those not appropriate at the moment
		#~ self.best_tiles_to_observe_now=[ObsTile(TaipanTile=x) for x in self.tiles]
		self.best_tiles_to_observe_now=[ObsTile(tp=x, lat=self.lat, local_sidereal_time=self.local_sidereal_time, moon=self.moon) for x in self.tiles]


	def find_the_best_tile_to_observe_now(self): # A combination of different methods
		"""
		This is a master function. Use multiple methods to find a best tile to be observed now.
		First, all tiles are assumed to be appropriate to observe. Then we exclude tiles that are not appropriate at the moment.
		"""
		
		# Exclude tiles already observed
		self.exclude_tiles_already_observed()
		
		# Position restrictions
		self.lower_RA_limit()
		self.upper_RA_limit()
		self.lower_altitude_limit()
		self.exclude_zenith()
		self.exclude_tiles_too_close_to_the_moon()
		
		# Magnitude restrictions
		self.exclude_tiles_below_limiting_magnitude() # user defined
		
		# Priorities
		self.find_tiles_closest_to_local_meridian() # TODO: tile_priority overrides this sorting
		self.tile_priority()
		
		# Get data
		best_tile=self.best_tiles_to_observe_now
		return best_tile

	def make_list_of_best_tiles_through_the_night(self): # FIX THIS!!!
		"""
		Make a list of best tiles observable through the night.
		"""
		todo=True
		

		
		# Observatory
		observatory = Observer.at_site("Anglo-Australian Observatory")
		
		# Determine sunset and sunrise times
		datenow=datetime.datetime.now().date()
		date='%d-%02d-%02d'%(datenow.year, datenow.month, datenow.day)
		time = Time('%s 23:30:00'%date)
		
		sun_set = observatory.sun_set_time(time, which="previous")
		sun_rise = observatory.sun_rise_time(time, which="next")
		
		for t in times:
			find_the_best_tile_to_observe_now(self) # BUT: 

			# Start of the night, end of the night. Time step: self.processing_time
			self.utc = Time(Time.now(), format='iso', scale='utc')
			self.utc.sidereal_time('mean', longitude=self.lon).value
		
		
		# Order by hour angle, starting from the evening.
		

	def exclude_tiles_already_observed(self):
		"""
		Exclude tiles with tile IDs in the list of tiles already observed.
		"""
		if len(self.observed_tile_ids)>0:
			good=[x for x in self.best_tiles_to_observe_now if x.TaipanTile.field_id not in self.observed_tile_ids]
			self.best_tiles_to_observe_now=good
		else:
			pass
	

	def lower_altitude_limit(self):
		"""
		Find tiles with altitude high enough to be observable.
		"""
		visible_tiles=[]
		for x in self.best_tiles_to_observe_now:
			if x.alt>self.alt_min:
				visible_tiles.append(x)
		self.best_tiles_to_observe_now=visible_tiles

	def exclude_zenith(self):
		"""
		Exclude zenith due to technical obstacles.
		"""
		visible_tiles=[]
		for x in self.best_tiles_to_observe_now:
			if x.alt<self.alt_max:
				visible_tiles.append(x)
		self.best_tiles_to_observe_now=visible_tiles

	def lower_RA_limit(self):
		"""
		If self.ra_min is not None, take only tiles with centre RA>=ra_min
		"""
		if self.ra_min:
			good=[x for x in self.best_tiles_to_observe_now if x.TaipanTile.ra>=self.ra_min]
			self.best_tiles_to_observe_now=good
			if len(good)<1:
				print 'WARNING: There is no tiles with RA>=%f.'%self.ra_min
		else:
			pass

	def upper_RA_limit(self):
		"""
		If self.ra_max is not None, take only tiles with centre RA<=ra_min
		"""
		if self.ra_max:
			good=[x for x in self.best_tiles_to_observe_now if x.TaipanTile.ra<=self.ra_max]
			self.best_tiles_to_observe_now=good
			if len(good)<1:
				print 'WARNING: There is no tiles with RA<=%f.'%self.ra_max
		else:
			pass

		
	def find_tiles_closest_to_local_meridian(self):
		"""
		Sort tiles according to their hour_angle. Tiles closest to local meridian are listed first.
		"""
		tiles=sorted(self.best_tiles_to_observe_now, key=lambda x: np.abs(x.hour_angle))
		self.best_tiles_to_observe_now=tiles
			
	def exclude_tiles_too_close_to_the_moon(self):
		"""
		Exclude tiles closer than self.moon_angdist_min from the Moon.
		"""
		good_tiles=[x for x in self.best_tiles_to_observe_now if x.angular_moon_distance>self.moon_angdist_min]
		self.best_tiles_to_observe_now=good_tiles
		print 'Number of tiles far enough from the Moon', len(good_tiles)
	
	
	def exclude_tiles_below_limiting_magnitude(self):
		"""
		Exclude tiles within magnitude ranges that include stars fainter than the limiting magnitude.
		"""
		if self.limiting_magnitude:
			good_tiles=[x for x in self.best_tiles_to_observe_now if x.TaipanTile.mag_max<=self.limiting_magnitude]
			self.best_tiles_to_observe_now=good_tiles
		else:
			pass
		
	def weather_conditions(self):
		"""
		Define limiting magnitude regarding the weather conditions.

        Parameters
        ----------
        seeing:
        
        Return:
        ----------        
        limiting_magnitude: float
			Limiting magnitude for given weather conditions.
        
        
        
        
        
        WHAT is a relation between seeing and limiting magnitude?
        
        sky transparency (--> limiting magnitude)		
		
		
		"""
		todo=True
		
		
		#~ if self.weather_data:
			# seeing=?
			
			
			#~ self.limiting_magnitude=TODO
		
		
			
	def tile_priority(self):
		# Tile priority: summing up the priorities of the TaipanTargets within the tile.
		if self.minimal_priority:
			good=[x for x in self.best_tiles_to_observe_now if x.TaipanTile.priority>=self.minimal_priority]
			if len(good)<1:
				print 'WARNING: There is no tiles with desired minimal_priority.'
				self.best_tiles_to_observe_now=good
			else:
				good=sorted(good, key=lambda x: x.TaipanTile.priority, reverse=True)
		else:
			# Choose the highest priority tiles
			good=sorted(self.best_tiles_to_observe_now, key=lambda x: x.TaipanTile.priority, reverse=True)
		self.best_tiles_to_observe_now=good	
		# If there is no tiles with minimal_priority, select the next one


		# TODO: DIFFICULTY
		# x.difficulty Difficulty: summing up the difficulties of the TaipanTargets within the tile. ##### WHAT IS THIS? it is probably relevant



class ObsTile():
	"""
	Observational parameters of a tile. Makes no observational decisions, only determines parameters.
	"""
	def __init__(self, tp=None, lat=None, local_sidereal_time=None, moon=None):
		"""
        Parameters
        ----------		
        TaipanTile:
        ra, dec: tile coordinates, degrees
        lat: observer's latitude, degrees
        local_sidereal_time: Local sidereal time, hours
        moon: astropy moon object
        
        hour_angle: Hour angle of a tile at time local_sidereal_time, hours
        alt: altitude of a center of a tile for a given hour_angle, degrees
        alt_max: maximal altitude of a center of a tile (in upper culmination), degrees
        alt_diff: 
        angular_moon_distance: Angular distance between the tile and the Moon, degrees
		"""
		self.TaipanTile=tp
		self.ra=tp.ra
		self.dec=tp.dec
		self.lat=lat
		self.local_sidereal_time=local_sidereal_time
		self.moon=moon

		"""
		Compute observational parameters
		"""
		self.hour_angle=self.determine_hour_angle()
		self.alt=self.altitude_of_an_object_in_the_sky()
		self.alt_max=self.max_altitude_of_an_object_in_the_sky()
		self.alt_diff=self.alt_max-self.alt
		self.angular_moon_distance=self.distance_between_two_points_in_the_sky(alpha1=self.ra, delta1=self.dec, alpha2=self.moon.ra.value, delta2=self.moon.dec.value)


	def __str__(self):
		string = 'TP TILE %d: RA=%3.1f, Dec=%2.1f, Ranking=%d, Altitude=%d, %d, %d, H=%.2f, Moon_dist=%d, mag_max=%d' % (self.TaipanTile.field_id, self.TaipanTile.ra, self.TaipanTile.dec, self.TaipanTile.priority, self.alt, self.alt_max, self.alt_diff, self.hour_angle, self.angular_moon_distance, self.TaipanTile.mag_max)
		return string

	def __repr__(self):
		string = 'TP TILE %d: RA=%3.1f, Dec=%2.1f, Ranking=%d, Altitude=%d, %d, %d, H=%.2f, Moon_dist=%d, mag_max=%d' % (self.TaipanTile.field_id, self.TaipanTile.ra, self.TaipanTile.dec, self.TaipanTile.priority, self.alt, self.alt_max, self.alt_diff, self.hour_angle, self.angular_moon_distance, self.TaipanTile.mag_max)
		return string

	def distance_between_two_points_in_the_sky(self, alpha1=None, delta1=None, alpha2=None, delta2=None):
		"""
		Determine the distance between two points in the sky.
		
		Parameters
        ----------
        alpha1, delta1: float, degrees
			RA and Dec for object 1
        alpha2, delta2: float, degrees
			RA and Dec for object 2
        
        Output
        ----------
        A: float, degrees
			Distance between two points in the sky.
		"""
		a1=np.deg2rad(alpha1)
		d1=np.deg2rad(delta1)
		a2=np.deg2rad(alpha2)
		d2=np.deg2rad(delta2)
		
		cos_A = np.sin(d1)*np.sin(d2) + np.cos(d1)*np.cos(d2)*np.cos(a1-a2)
		A=np.arccos(cos_A) # [0, 180] in radians
		A=np.rad2deg(A)
		return A # degrees

	def determine_hour_angle(self):
		"""
		Determine hour angle of a tile.
		
        Output
        ----------
        H: float, hours
			Hour angle of the tile.		
		"""
		H = self.local_sidereal_time - self.ra/15.0
		return H

	def altitude_of_an_object_in_the_sky(self):
		"""
		Determine altitude of a tile above horizon.
		
        Output
        ----------
        h: float, degrees
			Altitute of the tile above horizon.		
		"""
		# No need for atmospheric refraction correction.
		# Disagrees with Stellarium for about 5 degrees (Stellarium is using apparent altitude, but 5 degrees difference was for a star in zenith!!)
		hour_angle=np.deg2rad(self.hour_angle*15.0)
		dec=np.deg2rad(self.dec)
		lat=np.deg2rad(self.lat)
		sin_h = np.cos(hour_angle)*np.cos(dec)*np.cos(lat) + np.sin(dec)*np.sin(lat)
		h=np.arcsin(sin_h)
		h=np.rad2deg(h)
		return h

	def max_altitude_of_an_object_in_the_sky(self):
		"""
		Determine maximal altitude of a tile above horizon.
		
        Output
        ----------
        h: float, degrees
			Maximal altitute of the tile above horizon.		
		"""
		dec=np.deg2rad(self.dec)
		lat=np.deg2rad(self.lat)
		sin_h = np.cos(dec-lat)
		h=np.arcsin(sin_h)
		h=np.rad2deg(h)
		return h




# Why is altitude determined here, and not in Scheduler (where we can automatically skip tiles too low in the sky so we don't have to determine moon distance etc. of this file: if we are going to determine tile list for the entire night, then altitude changes overnight anyway. But...!

def test_tile_distribution_in_the_sky():
	fl = open('171308_1647_fw_tiling.pkl','rb')
	tiles = pickle.load(fl)[0]
	fl.close()
	print 'Number of tiles:', len(tiles)
	
	c=np.array([[x.ra/15.0, x.dec] for x in tiles])
	
	import matplotlib.pylab as plt
	fig=plt.figure()
	ax=fig.add_subplot(111)
	ax.scatter(c[:,0], c[:,1], s=5)
	plt.show()
	

"""
-------------------
Tests
-------------------
All the possible situations:
- only part of the sky is clear

"""


if __name__ == "__main__":
	#~ test_tile_distribution_in_the_sky()
	#~ exit(0)
	
	s=Scheduler(tiling_filename='171308_1647_fw_tiling.pkl', observed_tiles_filename='171308_1647_fw_tiling_observed_tiles.txt', alt_min=20.0, alt_max=50.0, moon_angdist_min=20.0, ra_min=200, ra_max=250, limiting_magnitude=9)
	print 'LST', s.local_sidereal_time
	#~ print s.find_the_best_tile_to_observe_now()
	t=s.find_the_best_tile_to_observe_now()
	t0=t[0]
	#~ print 'Best tile:', t.alt, t.hour_angle, t.angular_moon_distance, t.TaipanTile.priority
	print 'Best tile:', t0
	
	for x in t[:10]:
		print x
	
