"""
FunnelWeb: Decide which tile to observe next, based on sidereal time and observing conditions (weather, seeing etc.).
"""

# Should this code select only one tile to be observe next, or a few best candidates?

# Assumption: none of the tiles from the input file have not been observed yet. If Scheduler is run muptiple times during the night make sure you exclude tiles that have already been observed this night.
# Tiling will be run about once per month anyway so there should be a list of observed tiles.


import numpy as np
import math
import random
import pickle
import json
import urllib2
import datetime
from collections import defaultdict

from astropy.time import Time
from astropy.coordinates import get_moon
from astropy.coordinates import SkyCoord
from astropy.coordinates.earth import EarthLocation
import astropy.units as u
from astroplan import Observer
from astroplan import FixedTarget

import line_profiler
import pdb
import matplotlib.pyplot as plt

# Taipan
import taipan.core as tp
# Have to run the code in python 2. Astropy requires numpy>1.9.1. How to do that? It doesn't work with pip

# FunnelWeb Scheduler
import manage_list_of_observed_tiles
import params

#~ print params.params

"""
Constants
"""
# Minimal and maximal allowed altitude of the center of the tile
ALT_MIN=27.0
ALT_MAX=85.0

ALTITUDE_LOW_FRACTION = 0.8 # Fraction = Current altitude / altitude at local meridian. Altitude_low_fraction is thus the lowest acceptable fraction for a tile to be observed.

HOUR_ANGLE_AMP = 3 # hours, consider only tiles with H = +/- HOUR_ANGLE_AMP
# But be careful: when moon is on the local meridian, what happens?

# Minimal angular Moon distance.
# TODO: Should I include magnitude dependent Moon distances?
MOON_ANGDIST_MIN=15.0 # Minimal acceptable distance
MOON_ANGDIST_OK=30.0 # Distance where sky illumination by the Moon is negligible

TIME_PER_TILE=10#10 # [minutes], 10 minutes altogether per tile
SLEW_TIME_MIN=60.0 # [seconds], take slew time into consideration above this limit

TILE_DENSITY_RADIUS=6.0 #deg, radius to compute observed tile surface density

"""
Observer's coordinates
"""
# Siding Spring Observatory
# TODO: this data is automatic result from Google. Check if it is correct.
LAT=-31.2749 # deg South
LON=149.0685 # deg East


"""
Read the data
"""
#~ tiling_filename='171308_1647_fw_tiling.pkl'
tiling_filename=params.params['input_tiling_filename']
try:
    tiles = data[0]#[:10]
    settings = data[2]
except NameError:
    print 'Reading data...'
    fl = open(tiling_filename,'rb')
    data = pickle.load(fl)
    fl.close()				

    tiles = data[0]#[:10]
    settings = data[2]

print 'Number of tiles:', len(tiles)


observed_tiles_internal_filename = '%s_observed_tiles_internal.dat'%(tiling_filename[:-11])


class Scheduler():
    """
    Schedule FunnelWeb tile observations.
    """
    def __init__(self, weather_data_filename=None, alt_min=None, alt_max=None, ra_min=None, ra_max=None, moon_angdist_min=None, lat=None, lon=None, desired_priority=None, minimal_priority=None, time_per_tile=TIME_PER_TILE, limiting_magnitude=None, slew_time_min=SLEW_TIME_MIN, ra_current=None, dec_current=None, tile_density_radius=TILE_DENSITY_RADIUS, altitude_low_fraction=ALTITUDE_LOW_FRACTION):
        """
        Parameters
        ----------
        tiling_filename: string
            A pickle data filename of tiles generated by the tiling code.
        observed_tiles_filename: string
            A file with a list of tile IDs (a list of integers) that have already been observed. TODO: MAKE SURE THAT TILE IDs ARE UNIQUE.
        weather_data_filename: string
            Filename of the weather data.
        alt_min: float, degrees
            Minimal allowed altitude of a tile above the horizon. Default: 30.0.
        alt_max: float, degrees
            Maximal allowed altitude of a tile. (Avoid observing zenith). Default: 70.0.
        ra_min, ra_max: float, degrees
            Limit tiles within certain RA limits (e.g. when only part of the sky is clear).
        moon_angdist_min: float, degrees
            Angular distance between the Moon and the tile. Default: 20.0.
        lat, lon: float, degrees
            Observer's latitude and longitude. Default: lat=-31.2749, lon=149.0685 (Siding Spring).
        desired_priority: float
            Desired priority to be observed.
        minimal_priority: float
            User defined minimal tile priority to be observed.
        processing_time: float, seconds
            Total time spend per tile (slewing, exposure, calibration etc.). Default: 300.0.
        limiting_magnitude: float
            Magnitude of a faintest star to be observed. Default: None.
        ra_current, dec_current: float, degrees
            Current position of telescope. This position is needed to determine slew time to the next target.
            
            
        Data needed from Jeeves:
            ra_current, dec_current
            weather
        
        """
        
        """
        Read the data
        """
        #~ if tiling_filename:
            #~ try:
                #~ self.tiles = data[0]#[:10]
                #~ self.settings = data[2]
            #~ except NameError:
                #~ print 'Reading data...'
                #~ fl = open(tiling_filename,'rb')
                #~ data = pickle.load(fl)
                #~ fl.close()				
            
                #~ self.tiles = data[0]#[:10]
                #~ self.settings = data[2]
            
            #~ print 'Number of tiles:', len(self.tiles)
        #~ else:
            #~ print 'tiling_filename is None.'
            #~ exit(0)

        self.weather_conditions()

        self.tiles = tiles
        self.settings = settings


        # todo: check if this is already read in the method
        if weather_data_filename:
            self.weather_data=np.loadtxt(weather_data_filename) # STRING!!
        else:
            self.weather_data=None
        
        """
        Determine field_id and priority.
        Calculate_the_score should remain here.
        """
        # TODO: Later remove field_id as tile_id will be already available in the TaipanTiles.
        tiles2=[]
        priorities=[]
        #~ print 'WARNING: CORRECT TILE PRIORITIES!'
        for tile_id, x in enumerate(self.tiles):
            x.field_id=tile_id
            prior=x.calculate_tile_score(method=self.settings['ranking_method'], disqualify_below_min=self.settings['disqualify_below_min'], combined_weight=self.settings['combined_weight'], exp_base=self.settings['exp_base'])
            x.priority=prior
            priorities.append(prior)
            tiles2.append(x)
        self.tiles=tiles2
        self.max_priority=np.max(priorities)

        self.observed_tiles_internal_filename=params.params['observed_tiles_internal_filename']
        #~ self.observed_tiles_filename=observed_tiles_filename # TODO
        
        self.tile_density_radius=tile_density_radius
        
        
        """
        Global tile density of observed tiles: N(observed) / N(total) for each magnitude range
        """

        # Group tiles per magnitude range
        tiles_mag_range = defaultdict(list)
        for x in self.tiles:
            tiles_mag_range[tuple([float(x.mag_min), float(x.mag_max)])].append(x)
        self.tiles_mag_range={k: v for k, v in tiles_mag_range.iteritems()}

        """
        Observer's coordinates
        """
        if lat:
            self.lat=lat
        else:
            self.lat=LAT
        if lon:
            self.lon=lon
        else:
            self.lon=LON

        #observatory=EarthLocation('Anglo-Australian Observatory')
        #~ observatory = Observer(at_site="Anglo-Australian Observatory")
        #~ sun_set = apo.sun_set_time(time, which="next")


        # Observatory
        self.observatory = Observer.at_site("Anglo-Australian Observatory") # TODO: enter LAT and LON coordinates
        
        # Determine sunset and sunrise times
        datenow=datetime.datetime.now().date()
        date='%d-%02d-%02d'%(datenow.year, datenow.month, datenow.day)
        time = Time('%s 23:30:00'%date)
        
        self.sun_set = self.observatory.sun_set_time(time, which="previous").datetime
        self.sun_rise = self.observatory.sun_rise_time(time, which="previous").datetime # previous. This is correct.



        """
        Minimal altitude of a tile above the horizon.
        """
        if alt_min:
            if alt_min>ALT_MIN:
                self.alt_min=alt_min
            else: # user is not allowed to do funny things
                self.alt_min=ALT_MIN
                print 'WARNING: Minimal altitude too low. Set to %g degrees.'%ALT_MIN
        else:
            self.alt_min = ALT_MIN # degrees


        """
        Maximal tile altitude valid to observe - due to technical obstacles (cannot observe zenith). ???? DO WE NEED THIS?
        """
        if alt_max:
            if alt_max<ALT_MAX:
                self.alt_max=alt_max
            else: # user is not allowed to do funny things
                self.alt_max=ALT_MAX
                print 'WARNING: Maximal altitude limit too high. Set to %g degrees.'%ALT_MAX
        else:
            self.alt_max = ALT_MAX # degrees

        self.altitude_low_fraction = ALTITUDE_LOW_FRACTION


        """
        Limit RA in case of partly cloudy sky.
        """
        if ra_min:
            if ra_min>1e-10 and ra_min<360.0+1e-10:
                self.ra_min=ra_min
            else:
                self.ra_min=None
                print 'WARNING: You must enter 0 < ra_min < 360.'
        else:
            self.ra_min=None
            
        if ra_max:
            if ra_max>1e-10 and ra_max<360.0+1e-10:
                self.ra_max=ra_max
            else:
                self.ra_max=None
                print 'WARNING: You must enter 0 < ra_max < 360.'
        else:
            self.ra_max=None

        if self.ra_min and self.ra_max:
            if self.ra_min>self.ra_max or np.abs(self.ra_min-self.ra_max)<1e-6:
                print 'WARNING: ra_min and ra_max are not within valid limits or ra_min>ra_max.'

        self.hour_angle_amp = HOUR_ANGLE_AMP


        """
        Limiting magnitude
        """
        if limiting_magnitude:
            self.limiting_magnitude=limiting_magnitude
        else:
            self.limiting_magnitude=None

        """
        Minimal angular distance to the Moon
        """
        if moon_angdist_min is not None:
            if moon_angdist_min>MOON_ANGDIST_MIN: # user is not allowed to do funny things
                self.moon_angdist_min=moon_angdist_min
        else:
            self.moon_angdist_min = MOON_ANGDIST_MIN # degrees    


        #~ """
        #~ ------------------------------------
        #~ Time dependent variables
        #~ ------------------------------------
        #~ """

        """
        Determine local sidereal time
        """
        self.utc = Time(Time.now(), format='iso', scale='utc')
        self.local_sidereal_time = self.utc.sidereal_time('mean', longitude=self.lon).value

        """
        Current telescope position
        """
        if ra_current and dec_current:
            self.ra_current=ra_current
            self.dec_current=dec_current
        else:
            # todo: at what coordinates is telescope parked?
            self.ra_current=self.local_sidereal_time*15.0
            self.dec_current=-30.0


        """
        Moon
        """
        #~ self.moon = get_moon(self.utc)
        # Astropy Moon coordinates agree with Stellarium within a degree. This is good enough for the Scheduler.

        # User defined settings
        # Manually enter desired priority of the field. If None, tiles with highest priorities will be selected automatically.
        self.desired_priority=desired_priority
        self.minimal_priority=minimal_priority
        # TODO: Error check if value entered is valid
        
        # Processing time (time per tile)
        if time_per_tile:
            self.time_per_tile=time_per_tile
        else:
            self.time_per_tile=TIME_PER_TILE


    def __str__(self):
        string="""
        __str__:
        TODO=True
        """
        return string

    def __repr__(self):
        string="""
        __repr__:
        TODO=True
        """
        return string


    #~ @profile
    def find_the_best_tile_to_observe_now(self, date=None, time=None): # Run this to find the best tile to observe now.
        """
        Find the next tile to be observed. This is what Jeeves is going to call each time.
        """
        # If date and time is user specified
        if date:
            if time:
                tm=time
            else:
                tm='23:00:00'
            DateTime = Time('%s %s'%(date, tm))
       
            self.utc = Time(DateTime, format='iso', scale='utc')
            self.local_sidereal_time = self.utc.sidereal_time('mean', longitude=self.lon).value
            #~ self.moon = get_moon(self.utc)        
        
        

        
        # Receive info from Jeeves whether the last tile was successfully observed or not
        
        
        # Receive weather data from Jeeves
        
        
        # Receive telescope position from Jeeves
        # self.ra_current=
        # self.dec_current=
        
        self.best_tiles_to_observe_now=self.init_best_tiles_to_observe(exclude_observed=True, only_1_tile_now=True)
        best_tiles = self.find_the_best_tile_to_observe()
        
        
        # Assume that this tile is going to be observed successfully. Add it on the list of observed tiles.
        self.add_tile_to_list_of_observed_tiles(tile_id=best_tiles[0].TaipanTile.field_id)
        
        return best_tiles

    #~ @profile
    def make_list_of_best_tiles_through_the_night(self, date=None, time=None):
        """
        Make a list of best tiles observable through the night.
        
        Output: observing_plan.txt
        # observing_ideal observing_start observing_stop fieldID path_to_config_file
        1030 1000 1100 fieldID /observers_files/taipan/YYYYMMDD/tile_pk_HHMMSS.obs_config.json
        
        observing_ideal = meridian transit time
        observing_start, observing_stop: observing_ideal +/- dt, dt is determined using weights
        
        Should times be given in UT?
        What is the json file (e.g. list of stars with coordinates etc.?)
        
        TODO: What is ObsConfig file?
        """     
        # Observatory
        #~ observatory = Observer.at_site("Anglo-Australian Observatory") # TODO: enter LAT and LON coordinates
        
        #~ pdb.set_trace()
        
        # If date and time is user specified
        if date:
            if time:
                tm=time
            else:
                tm='23:00:00'
            DateTime = Time('%s %s'%(date, tm))
            sun_set = self.observatory.sun_set_time(DateTime, which="previous").datetime
            sun_rise = self.observatory.sun_rise_time(DateTime, which="previous").datetime # previous. This is correct.
        
        else:
            #~ # Determine sunset and sunrise times
            #~ datenow=datetime.datetime.now().date()
            #~ date='%d-%02d-%02d'%(datenow.year, datenow.month, datenow.day)
            sun_set=self.sun_set
            sun_rise=self.sun_rise
        
        sunset=self.observatory.datetime_to_astropy_time(sun_set)
        
        f=open('observing_plan_%s.dat'%date, 'wb')

        # UTC times
        times = [sun_set + datetime.timedelta(minutes=i*self.time_per_tile) for i in range(1, 100) if sun_set + datetime.timedelta(minutes=i*self.time_per_tile)<=sun_rise]
        print 'Number of tiles this night:', len(times)
        
        # Convert UTC times to LST
        times_lst = [Time(t).utc.sidereal_time('mean', longitude=self.lon).value for t in times]

        time_efficiency=[]
        telescope_positions=[] # for testing purposes
        

        selected_tiles=[]
        count=1
        for t, lst in zip(times, times_lst):
            t_start=datetime.datetime.now()      
            #~ utc = Time('%d-%02d-%02d %02d:%02d:%02d'%(t.year, t.month, t.day, t.hour, t.minute, t.second), format='iso', scale='utc')
            utc = self.observatory.datetime_to_astropy_time(t)
            moon = get_moon(utc)

            # TODO: Where are ra_current and dec_current updated? Jeeves needs to tell us where the telescope is (or we take coordinates of the previously selected tile; however, at the beginning of the night we need to know where the telescope is, or when we take over from Taipan, or if for some reason telescope is slewed manually etc.).
            try:
                ra_current=best_tile.TaipanTile.ra
                dec_current=best_tile.TaipanTile.dec
            except:
                # TODO
                #~ ra_current=self.ra_current
                #~ dec_current=self.dec_current
                ra_current=self.ra_current
                dec_current=-70.0

            # Here exclude tiles that have already been observed.
            # Two parallel lists: one internal and one external. External includes tiles that were confirmed to be observed by Jeeves.
            # But while the last tile is being observed and scheduler is waiting for Jeeves to receive confirmation about observation, scheduler needs to select a new tile.
            # So the assumption of scheduler is that the tile that is being observed in the moment is going to be observed with success and it adds it to the internal 'observed' list.
        


            self.local_sidereal_time=lst # TODO: check if this violates any other things. Why cant I insert LST to init_best_tiles...??
            #~ print 'set lst', lst, self.local_sidereal_time, lst*15.0
            
            self.best_tiles_to_observe_now, tiles_mag_range_tmp = self.init_best_tiles_to_observe(local_sidereal_time=lst, moon=moon, observatory=self.observatory, sunset=sunset, ra_current=ra_current, dec_current=dec_current) # TODO: why sunset, but I skip sunrise?
            # Init includes: Init only those that are within HOUR_ANGLE_AMP
            
            #~ print 'LEN 0000000', len(self.best_tiles_to_observe_now)
            
            # Find best tile for time t
            tls=self.find_the_best_tile_to_observe(tiles_mag_range=tiles_mag_range_tmp)
            
            if len(tls)<1:
                print 'len TLS<1', len(self.best_tiles_to_observe_now), lst
            
            # Tiles cannot be selected twice
            # TODO: this is not needed anymore as there is an external list ob observed tiles available.
            do_selection=True
            i=0
            while do_selection:
                best_tile=tls[i]
                if best_tile.TaipanTile.field_id not in selected_tiles:
                    selected_tiles.append(best_tile.TaipanTile.field_id)
                    break
                else:
                    i+=1
            
            # TODO: among the tiles with best weights, select one closest to local meridian!!!
            
            
            
            # Assign TILE ID
            # RA, DEC, TIME
            tile_id_time = datetime.datetime.now()
            # TODO: time should be in UTC (more universal + there is no problems with daylight savings time)
            sign=0
            if best_tile.TaipanTile.dec>0.0:
                sign=1
            tile_id = '%03d%01d%02d%04d%02d%02d%02d%02d'%(best_tile.TaipanTile.ra, sign, np.abs(best_tile.TaipanTile.dec), tile_id_time.year, tile_id_time.month, tile_id_time.day, tile_id_time.hour, tile_id_time.minute)
            # Time is the same for multiple tiles because code is faster than 1 minute. Correct that.
            
            
            # Update list of observed tiles
            manage_list_of_observed_tiles.add_tile_id_internal_to_the_list(tile_id_internal=best_tile.TaipanTile.field_id, filename=self.observed_tiles_internal_filename)
            # TODO: LATER update the code: wait for Jeeves to confirm that tile has been observed successfully
            self.observed_tile_ids.append(int(best_tile.TaipanTile.field_id))
            mag_range=(float(best_tile.TaipanTile.mag_min), float(best_tile.TaipanTile.mag_max))
            try:
                obs_tiles_tmp=self.observed_tiles[mag_range]
                obs_tiles_tmp.append(best_tile.TaipanTile)
            except:
                obs_tiles_tmp=[best_tile.TaipanTile]
            self.observed_tiles[mag_range]=obs_tiles_tmp

            print 'TILE ID', tile_id, 'Separately', best_tile.TaipanTile.ra, sign, np.abs(best_tile.TaipanTile.dec), tile_id_time.year, tile_id_time.month, tile_id_time.day, tile_id_time.hour, tile_id_time.minute
            print count, len(times), t, lst*15.0, 'LOCAL TIME = ', t-datetime.timedelta(hours=11.0), 'obs tiles len', mag_range, len(self.observed_tiles[mag_range])
            print 'LST=%s'%(('%.11f'%lst).rjust(14)), best_tile #, best_tile.meridian_transit_time.datetime
            
            telescope_positions.append([best_tile.TaipanTile.ra, best_tile.TaipanTile.dec, moon.ra.value, moon.dec.value, best_tile.angular_moon_distance])
            

            # Print out the data
            H_amp = best_tile.estimate_best_time_interval_to_observe_tile()
            if H_amp is None:
                todo=True
                
            # TODO: check if this times are during the night, not e.g. just before sunset or just after sunrise, otherwise limit them within sunset and sunrise time
            #~ print 't, H_amp', t, H_amp
            observing_start = t - datetime.timedelta(hours=H_amp)
            observing_stop = t + datetime.timedelta(hours=H_amp)
            observing_ideal = Time(t - datetime.timedelta(hours=best_tile.hour_angle)).utc.sidereal_time('mean', longitude=self.lon).value # Do I insert time NOW or time of meridian crossing?
            
            
            """
            Print output
            """
            line='%02d%02d %02d%02d %02d%02d %05d /observers_files/funnelweb/YYYYMMDD/%05d_HHMMSS.obs_config.json'%(t.hour, t.minute, observing_start.hour, observing_start.minute, observing_stop.hour, observing_stop.minute, best_tile.TaipanTile.field_id, best_tile.TaipanTile.field_id)
            print line # TODO: change t. to observing_ideal
           
            # TODO: what happens with observing_ideal for tiles at ALT=90? Because there is a limit at 85 degrees.
            f.write(line+'\n')
        
            count+=1
            
            t_end=datetime.datetime.now() 
            time_efficiency.append((t_end-t_start).seconds)
            
            # PLOT
            self.plot(moon=moon, lst=lst, best_tiles=tls, tiles=self.tiles_mag_range, best_tile=best_tile, i=count-1, ra_current=ra_current, dec_current=dec_current, telescope_positions=telescope_positions)
            
            
            
            print
            
            
        f.close()
        
        print 'Average time to find the next tile: [seconds]', np.mean(time_efficiency)
        
        telescope_positions=np.array(telescope_positions)
        return telescope_positions
 

    def init_best_tiles_to_observe(self, local_sidereal_time=None, moon=None, observatory=None, sunset=None, ra_current=None, dec_current=None, exclude_observed=False):
        """
        Init ObsTiles. At the beginning all tiles are assumed good to observe, then we throw away those not appropriate at the moment.
        """
        #~ # TODO: insert current telescope position in order to estimate slew time
        
        if local_sidereal_time is None:
            local_sidereal_time=self.local_sidereal_time
        if moon is None:
            self.moon = get_moon(self.utc)
            moon=self.moon # fix this
        if ra_current is None:
            ra_current=self.ra_current
        if dec_current is None:
            dec_current=self.dec_current


        #~ pdb.set_trace()

        # Init only those that are within HOUR_ANGLE_AMP
        tiles, tiles_mag_range = self.select_only_tiles_within_hour_angle_amp(S=local_sidereal_time)
        
        #~ print 'LEN 1', len(tiles)
           
        #~ if exclude_observed:
        tiles=self.exclude_tiles_already_observed(tiles=tiles)
        
        #~ print 'LEN 2', len(tiles)

        # To determine surface density of observed tiles: devide into mag_range classes
        self.manage_observed_tiles() # has to be list of ObsTiles

        #~ self.internal_observed_tiles_mag_range_read()

        # All candidate tiles: exclude those that are not visible; we need this to determine density weights
        #~ self.select_only_tiles_within_hour_angle_amp_all_candidate_tiles()
        

        result=[ObsTile(tp=x, lat=self.lat, local_sidereal_time=local_sidereal_time, moon=moon, observatory=observatory, sunset=sunset, ra_current=ra_current, dec_current=dec_current, max_priority=self.max_priority, tile_density_radius=self.tile_density_radius, observed_tiles=self.observed_tiles, altitude_low_fraction=self.altitude_low_fraction) for x in tiles]

        return result, tiles_mag_range


    #~ @profile    
    def find_the_best_tile_to_observe(self, tiles_mag_range=None): # A combination of different methods. Used by both: find_the_best_tile_to_observe_now and make_list_of_best_tiles_through_the_night
        """
        This is a master function. Use multiple methods to find a best tile to be observed now.
        First, all tiles are assumed to be appropriate to observe. Then we exclude tiles that are not appropriate at the moment.
        """  
        # Exclude tiles already observed. Only tiles from the input tiling file are considered + tiles already selected in the all-night schedule.
        #~ tiles=self.exclude_tiles_already_observed(tiles=self.best_tiles_to_observe_now)
        #~ self.best_tiles_to_observe_now=tiles

        # Position restrictions
        self.lower_RA_limit()
        self.upper_RA_limit()
        self.lower_altitude_limit() # Tiles visible on this day
        self.exclude_zenith()
        self.exclude_tiles_too_close_to_the_moon()
        
        # Magnitude restrictions
        self.exclude_tiles_below_limiting_magnitude() # user defined
        
        # Priorities
        # Determine weights for candidate tiles:
        for x in self.best_tiles_to_observe_now:
            #~ x.weighting(tiles_mag_range=tiles_mag_range, internal_observed_tiles_mag_range=self.internal_observed_tiles_mag_range)
            x.weighting(tiles_mag_range=tiles_mag_range, internal_observed_tiles_mag_range=self.observed_tiles)
        
        b = sorted(self.best_tiles_to_observe_now, key=lambda y: y.weight, reverse=True)
        self.best_tiles_to_observe_now=b

        #~ self.find_tiles_closest_to_local_meridian() # TODO: tile_priority overrides this sorting
        #~ self.tile_priority()
        
        # Get data
        best_tile=self.best_tiles_to_observe_now
        return best_tile


    def lower_altitude_limit(self):
        """
        Find tiles with altitude high enough to be observable.
        """
        visible_tiles=[]
        for x in self.best_tiles_to_observe_now:
            if x.alt>self.alt_min:
                visible_tiles.append(x)
        self.best_tiles_to_observe_now=visible_tiles

    def exclude_zenith(self):
        """
        Exclude zenith due to technical obstacles.
        """
        visible_tiles=[]
        for x in self.best_tiles_to_observe_now:
            if x.alt<self.alt_max:
                visible_tiles.append(x)
        self.best_tiles_to_observe_now=visible_tiles

    def lower_RA_limit(self):
        """
        If self.ra_min is not None, take only tiles with centre RA>=ra_min
        """
        if self.ra_min:
            good=[x for x in self.best_tiles_to_observe_now if x.TaipanTile.ra>=self.ra_min]
            self.best_tiles_to_observe_now=good
            if len(good)<1:
                print 'WARNING: There is no tiles with RA>=%f.'%self.ra_min
        else:
            pass

    def upper_RA_limit(self):
        """
        If self.ra_max is not None, take only tiles with centre RA<=ra_min
        """
        if self.ra_max:
            good=[x for x in self.best_tiles_to_observe_now if x.TaipanTile.ra<=self.ra_max]
            self.best_tiles_to_observe_now=good
            if len(good)<1:
                print 'WARNING: There is no tiles with RA<=%f.'%self.ra_max
        else:
            pass


    def select_only_tiles_within_hour_angle_amp(self, S=None):
        """
        Exclude tiles that are not visible right now. Keep only those close to the local meridian (H_amp away from the local meridian at most).
        """
        #~ S = self.local_sidereal_time
        H_amp = self.hour_angle_amp
        
        ra_min = S - H_amp
        if ra_min<0.0:
            ra_min=24.0+ra_min
        ra_min *= 15.0
        
        ra_max = S + H_amp
        if ra_max>24.0:
            ra_max=ra_max-24.0
        ra_max *= 15.0

        if ra_min<ra_max:
            b=[x for x in self.tiles if x.ra>ra_min and x.ra<ra_max]
        elif ra_min>ra_max:
            b1=[x for x in self.tiles if x.ra>ra_min]
            b2=[x for x in self.tiles if x.ra<ra_max]
            b=b1+b2

        B=b

        # All candidate tiles
        H_amp = H_amp + 2.0*self.tile_density_radius/15.0
        
        ra_min = S - H_amp
        if ra_min<0.0:
            ra_min=24.0+ra_min
        ra_min *= 15.0
        
        ra_max = S + H_amp
        if ra_max>24.0:
            ra_max=ra_max-24.0
        ra_max *= 15.0

        new_dict={}
        if ra_min<ra_max:
            for k, v in self.tiles_mag_range.iteritems():
                b=[x for x in v if x.ra>ra_min and x.ra<ra_max]
                new_dict[k]=b
        elif ra_min>ra_max:
            for k, v in self.tiles_mag_range.iteritems():
                b=[]
                b=[x for x in v if x.ra>ra_min]
                new_dict[k]=b

            for k, v in self.tiles_mag_range.iteritems():
                b=[]
                b=[x for x in v if x.ra<ra_max]
                b0=new_dict[k]
                new_dict[k]=b0+b

        return B, new_dict

        
    def find_tiles_closest_to_local_meridian(self):
        """
        Sort tiles according to their hour_angle. Tiles closest to local meridian are listed first.
        """
        tiles=sorted(self.best_tiles_to_observe_now, key=lambda x: np.abs(x.hour_angle))
        self.best_tiles_to_observe_now=tiles
            
    def exclude_tiles_too_close_to_the_moon(self):
        """
        Exclude tiles closer than self.moon_angdist_min from the Moon.
        """
        good_tiles=[x for x in self.best_tiles_to_observe_now if x.angular_moon_distance>self.moon_angdist_min]
        self.best_tiles_to_observe_now=good_tiles    
    
    def exclude_tiles_below_limiting_magnitude(self):
        """
        Exclude tiles within magnitude ranges that include stars fainter than the limiting magnitude.
        """
        if self.limiting_magnitude:
            good_tiles=[x for x in self.best_tiles_to_observe_now if x.TaipanTile.mag_max<=self.limiting_magnitude]
            self.best_tiles_to_observe_now=good_tiles
        else:
            pass
        
    def weather_conditions(self):
        """
        Define limiting magnitude regarding the weather conditions.

        Parameters
        ----------
        seeing:
        
        Return:
        ----------        
        limiting_magnitude: float
            Limiting magnitude for given weather conditions.
        
        
        
        
        
        WHAT is a relation between seeing and limiting magnitude?
        
        sky transparency (--> limiting magnitude) 
        
        
        Sky transparency: -10 is probably rain, -20 is clear (with possible cirruses). But this is the average.       
        
        
        """
        todo=True
        
        
        #~ if self.weather_data:
            # seeing=?
            
            
            #~ self.limiting_magnitude=TODO
       
       
       
        

        data = urllib2.urlopen("http://site.aao.gov.au/met/metdata.dat").read(500) # read only 20 000 chars
        data = data.split("\n") # then split it into lines
        
        
        # Check if date and time are close enough to our observations
        
        date=data[0].replace('"', '').replace('.', '').replace(' ', '')
        date_spl=date.split('-')
        month=int(date_spl[0])
        day=int(date_spl[1])
        year=int(date_spl[2])
        
        spl=data[1].split('\t')
        
        time=spl[0].split(':')
        hour=int(time[0])
        minute=int(time[1])
        
        time_weather = datetime.datetime(year, month, day, hour, minute)
        time_now = datetime.datetime.now()
        
        if time_weather>time_now:
            dt=time_weather-time_now
        else:
            dt=time_now-time_weather
        
        dt=str(dt).split(':')
        dt=float(dt[0])*60.0+float(dt[1])
        print 'weather dt', dt
        # Note: There is 1 hour difference between Stromlo and SSO. Why??!?
        
        #~ seeing=float(spl[13]) # there is no seeing info in the data
        sky_transparency=float(spl[13])

        #~ print 'seeing, sky_transparency', seeing, sky_transparency
        print 'sky_transparency', sky_transparency
        
        
        
            
    def tile_priority(self):
        # Tile priority: summing up the priorities of the TaipanTargets within the tile.
        if self.minimal_priority:
            good=[x for x in self.best_tiles_to_observe_now if x.TaipanTile.priority>=self.minimal_priority]
            if len(good)<1:
                print 'WARNING: There is no tiles with desired minimal_priority.'
                self.best_tiles_to_observe_now=good
            else:
                good=sorted(good, key=lambda x: x.TaipanTile.priority, reverse=True)
        else:
            # Choose the highest priority tiles
            good=sorted(self.best_tiles_to_observe_now, key=lambda x: x.TaipanTile.priority, reverse=True)
        self.best_tiles_to_observe_now=good    
        # If there is no tiles with minimal_priority, select the next one


    def manage_observed_tiles(self):
        """
        This list of observed tiles per magnitude range is needed to determine sky surface density of observed tiles.
        """
        tiles_dict={x.field_id: x for x in self.tiles}

        obs_tiles_dict = defaultdict(list)
        # TODO: if --> try?
        if self.observed_tiles_internal_filename:
            #~ try:
            observed_tiles=np.loadtxt(self.observed_tiles_internal_filename, comments='#', ndmin=1)
            self.observed_tile_ids=[int(x) for x in observed_tiles] # a list of integers (IDs)

            # Split into magnitude ranges
            for t in self.observed_tile_ids:
                x=tiles_dict[t]
                obs_tiles_dict[(float(x.mag_min), float(x.mag_max))].append(x)
            obs_tile_coo2={k: v for k, v in obs_tiles_dict.iteritems()} # because obs_tile_coo is defaultdict (creates new list in the dict if a key that does not exist yet is called)
            self.observed_tiles=obs_tile_coo2
            #~ except:
                #~ self.observed_tile_ids=[]
                #~ self.observed_tiles={}
                #~ print 'WARNING: File with tile IDs already observed cannot be read.'
        else:
            self.observed_tile_ids=[]        

    #~ def internal_observed_tiles_mag_range_read(self):
        #~ obs_tiles_dict = defaultdict(list)
        #~ try:
            #~ observed_tiles_internal=np.loadtxt(self.observed_tiles_internal_filename, ndmin=1)
            #~ for x in observed_tiles_internal:
                #~ tileid=int(x[0])
                #~ mag_min=float(x[1])
                #~ mag_max=float(x[1])
                #~ obs_tiles_dict[(mag_min, mag_max)].append(tileid)
            #~ self.internal_observed_tiles_mag_range=obs_tiles_dist
        #~ except:
            #~ self.internal_observed_tiles_mag_range=obs_tiles_dict
            #~ pass

    def exclude_tiles_already_observed(self, tiles=None):
        # Exclude tiles that have already been observed
        """
        Internal: My tile_ids, stored in the TaipanTile.field_id
        External: Tile IDs with RA, DEC, DATE
        """
        try:
            observed_tiles_internal=np.loadtxt(self.observed_tiles_internal_filename, ndmin=1)
            observed_tiles_internal=[int(x) for x in observed_tiles_internal]
            #~ print observed_tiles_internal
        #~ print 'tiles', tiles
        
            try:
                tiles2=[x for x in tiles if x.field_id not in observed_tiles_internal]
            except:
                tiles2=[x for x in tiles if x.TaipanTile.field_id not in observed_tiles_internal]
        except:
            # No tiles were observed yet.
            tiles2=tiles
        

        return tiles2

    def add_tile_to_list_of_observed_tiles(self, tile_id=None):
        #~ try:
            #~ observed_tiles_internal=np.loadtxt(observed_tiles_internal_filename, ndmin=1)
            #~ observed_tiles_internal=[int(x) for x in observed_tiles_internal]
            #~ observed_tiles_internal.append(tile_id)
        #~ except:
            #~ observed_tiles_internal=[tile_id]
        
        #~ # TODO: later, when number of observed tiles becomes big, add only the last line. Do not overwrite file each time.
        #~ f=open(observed_tiles_internal_filename, 'wb')
        #~ for x in observed_tiles_internal:
            #~ f.write(str(int(x))+'\n')
        #~ f.close()
        
        manage_list_of_observed_tiles.add_tile_id_internal_to_the_list(tile_id_internal=tile_id, filename=observed_tiles_internal_filename)
  


    def print_selected_tile_to_json(self):
        """
        Generate dictionary of output data and write to a json file.
        """
        # Generate dictionary
        t = self.best_tiles_to_observe_now[0]
        data={
        'tile_id': t.TaipanTile.field_id
        }
        #~ 'TaipanTile': t.TaipanTile # Class is not serializable
        
        # Write
        # Each time add timestamp to json file. Is this a good idea? Because then Jeeves has to search for the latest filename each time.
        timestamp=self.utc.value.replace(' ', '--')
        filename='selected_tile_%s.json'%timestamp
        with open(filename, 'w') as outfile:  
            json.dump(data, outfile)    
        print '%s created.'%filename


    def plot(self, moon=None, lst=None, best_tiles=None, tiles=None, best_tile=None, i=None, ra_current=None, dec_current=None, telescope_positions=None):
        lst=lst*15.0
        if lst>180:
            lst=lst-360.0
        plot_ra_amp=50

        #~ print 'plot LST', lst

        w=np.array([[x.TaipanTile.ra, x.TaipanTile.dec, x.weight] for x in best_tiles if x.hour_angle<6.0])
        w=np.array([x if x[0]<180 else [x[0]-360.0, x[1], x[2]] for x in w])
        w=np.array(sorted(w, key=lambda y: y[2]))
        
        
        telescope_positions=np.array([[x[0] if x[0]<180 else x[0]-360.0, x[1]] for x in telescope_positions])
        
        tl=[x for x in tiles.itervalues()]
        tiles=[x for sublist in tl for x in sublist]

        tiles=np.array([[x.ra, x.dec] for x in tiles])
        tiles=np.array([x if x[0]<180 else [x[0]-360.0, x[1]] for x in tiles])


       
        fig=plt.figure()
        ax=fig.add_subplot(111)
        ax.axvline(x=lst)
        ax.axvline(x=lst-15.0, alpha=0.5)
        ax.axvline(x=lst+15.0, alpha=0.5)
        ax.scatter(tiles[:,0], tiles[:,1], c='grey', alpha=0.1)
        
        m=[moon.ra.value if moon.ra.value<180.0 else moon.ra.value-360.0, moon.dec.value]
        ax.scatter(m[0], m[1], c='red', s=200)
        
        cb=ax.scatter(w[:,0], w[:,1], c=w[:,2], vmin=0, vmax=1, cmap=plt.cm.RdYlGn_r)
        plt.colorbar(cb)

        
        # Current telescope position
        ctp=[ra_current if ra_current<180.0 else ra_current-360.0, dec_current]
        #~ ax.scatter(ctp[0], ctp[1], c='None', edgecolor='k', s=150)
        ax.scatter(telescope_positions[:,0], telescope_positions[:,1], c='None', edgecolor='k', s=150)
        ax.plot(telescope_positions[:,0], telescope_positions[:,1], c='k')
  
        
        bt=[best_tile.TaipanTile.ra if best_tile.TaipanTile.ra<180.0 else best_tile.TaipanTile.ra-360.0, best_tile.TaipanTile.dec]
        #~ ax.scatter([best_tile.TaipanTile.ra], [best_tile.TaipanTile.dec], c='None', edgecolor='r', s=150)
        ax.scatter(bt[0], bt[1], c='None', edgecolor='r', s=150)  
        
        
        ax.set_xlim([lst-plot_ra_amp, lst+plot_ra_amp])
        ax.set_xlabel('RA [deg, -180:180]')
        ax.set_ylabel('DEC [deg]')
        #~ plt.show()
        plt.savefig('seq/%3d.png'%i)
        plt.close()  


class ObsTile():
    """
    Observational parameters of a tile. This class makes no observational decisions, it only determines parameters.
    """
    #~ @profile
    def __init__(self, tp=None, lat=None, local_sidereal_time=None, moon=None, observatory=None, sunset=None, ra_current=None, dec_current=None, max_priority=None, tile_density_radius=None, local_surface_area=None, tile_density_global=None, observed_tiles=None, altitude_low_fraction=None):
        """
        Parameters
        ----------        
        TaipanTile:
        ra, dec: tile coordinates, degrees
        lat: observer's latitude, degrees
        local_sidereal_time: Local sidereal time, hours
        moon: astropy moon object
        observatory: astroplan observatory object
        sunset: astropy Time object: sunset time
        
        hour_angle: Hour angle of a tile at time local_sidereal_time, hours
        alt: altitude of a center of a tile for a given hour_angle, degrees
        alt_max: maximal altitude of a center of a tile (in upper culmination), degrees
        alt_diff: 
        angular_moon_distance: Angular distance between the tile and the Moon, degrees
        """
        self.TaipanTile=tp
        self.ra=tp.ra
        self.dec=tp.dec
        self.lat=lat
        self.ra_current=ra_current
        self.dec_current=dec_current
        self.altitude_low_fraction=altitude_low_fraction
        self.max_priority=max_priority
        self.tile_density_radius=tile_density_radius
        self.observed_tiles=observed_tiles # ACTUALLY not a good idea as it takes a lot of RAM eventually over time   
        
        self.local_sidereal_time=local_sidereal_time
        self.moon=moon
        self.observatory=observatory
        self.sunset=sunset

        """
        Compute observational parameters
        """
        self.hour_angle=self.determine_hour_angle()
        self.alt=self.altitude_of_an_object_in_the_sky()
        
        # These params could be set later, only for visible tiles
        self.alt_max=self.max_altitude_of_an_object_in_the_sky()
        self.angular_moon_distance=self.distance_between_two_points_in_the_sky(alpha1=self.ra, delta1=self.dec, alpha2=self.moon.ra.value, delta2=self.moon.dec.value)


    @property
    def local_sidereal_time(self):
        return self.local_sidereal_time

    @local_sidereal_time.setter
    def local_sidereal_time(self, value):    
        self.local_sidereal_time = value
        
    def __str__(self):
        string = 'TP TILE %s: RA=%s, Dec=%s, Ranking=%s, w=%s, Altitude=%s, H=%s, Moon_dist=%s, mag_max=%s' % (('%d'%self.TaipanTile.field_id).rjust(5), ('%3.1f'%self.TaipanTile.ra).rjust(5), ('%2.1f'%self.TaipanTile.dec).rjust(5), ('%d'%self.TaipanTile.priority).rjust(5), ('%2.4f'%(self.weight*1000.0)).rjust(8), ('%d'%self.alt).rjust(2), ('%.2f'%self.hour_angle).rjust(6), ('%d'%self.angular_moon_distance).rjust(3), ('%d'%self.TaipanTile.mag_max).rjust(2)) + ' surface density %f %d %d'%(self.surface_density[0], self.surface_density[1], self.surface_density[2])
        return string

    #~ def __repr__(self):
        #~ string = 'TP TILE %d: RA=%3.1f, Dec=%2.1f, Ranking=%d, Altitude=%d, %d, %d, H=%.2f, Moon_dist=%d, mag_max=%d' % (self.TaipanTile.field_id, self.TaipanTile.ra, self.TaipanTile.dec, self.TaipanTile.priority, self.alt, self.alt_max, self.alt_diff, self.hour_angle, self.angular_moon_distance, self.TaipanTile.mag_max)
        #~ return string

    #~ @profile
    def distance_between_two_points_in_the_sky(self, alpha1=None, delta1=None, alpha2=None, delta2=None):
        """
        Determine the distance between two points in the sky.
        
        Parameters
        ----------
        alpha1, delta1: float, degrees
            RA and Dec for object 1
        alpha2, delta2: float, degrees
            RA and Dec for object 2
        
        Output
        ----------
        A: float, degrees
            Distance between two points in the sky.
        """
        a1=np.deg2rad(alpha1)
        d1=np.deg2rad(delta1)
        a2=np.deg2rad(alpha2)
        d2=np.deg2rad(delta2)
        
        cos_A = np.sin(d1)*np.sin(d2) + np.cos(d1)*np.cos(d2)*np.cos(a1-a2)
        A=np.arccos(cos_A) # [0, 180] in radians
        A=np.rad2deg(A)
        return A # degrees

    #~ @profile
    def determine_azimuth(self, ra=None, dec=None, alt=None, H=None):
        """
        Azimuth of the tile.
        """
        #~ alpha=np.deg2rad(ra)
        # TODO: remove ra.
        delta=np.deg2rad(dec)
        h=np.deg2rad(alt)
        phi=np.deg2rad(self.lat)
        hour_angle = np.deg2rad(H*15.0)
        
        #~ cosA = (np.sin(delta) - np.sin(h)*np.sin(phi)) / (np.cos(h)*np.cos(phi))
        #~ sinA = - np.sin(hour_angle) * np.cos(delta) / np.cos(h)

        cosA = (np.sin(h)*np.sin(phi) - np.sin(delta)) / (np.cos(h)*np.cos(phi))
        sinA = np.sin(hour_angle) * np.cos(delta) / np.cos(h)
        
        A = math.atan2(sinA, cosA)
        A = np.rad2deg(A)
        
        #~ A=np.arccos(cosA)
        #~ A=np.rad2deg(A)
        
        #~ H=np.deg2rad(H*15.0)
        #~ if np.sin(H)>0:
            #~ A=360.0-A
    
            
        return A

    def determine_hour_angle(self, ra=None):
        """
        Determine hour angle of a tile.
        
        Output
        ----------
        H: float, hours
            Hour angle of the tile.        
        """
        if ra:
            H = self.local_sidereal_time - ra/15.0
        else:
            H = self.local_sidereal_time - self.ra/15.0
        if H>12:
            H=24.0-H
        if H<-12:
            H=24.0+H
        # TODO: check again why does this happen
        return H

    def altitude_of_an_object_in_the_sky(self, hour_angle=None, dec=None):
        """
        Determine altitude of a tile above horizon.
        
        Output
        ----------
        h: float, degrees
            Altitute of the tile above horizon.        
        """
        # No need for atmospheric refraction correction.
        # Disagrees with Stellarium for about 5 degrees (Stellarium is using apparent altitude, but 5 degrees difference was for a star in zenith!!)
        
        if hour_angle and dec:
            hour_angle=np.deg2rad(hour_angle*15.0)
            dec=np.deg2rad(dec)
        else:
            hour_angle=np.deg2rad(self.hour_angle*15.0)
            dec=np.deg2rad(self.dec)
        
        lat=np.deg2rad(self.lat)
        sin_h = np.cos(hour_angle)*np.cos(dec)*np.cos(lat) + np.sin(dec)*np.sin(lat)
        h=np.arcsin(sin_h)
        h=np.rad2deg(h)
        return h

    def max_altitude_of_an_object_in_the_sky(self):
        """
        Determine maximal altitude of a tile above horizon.
        
        Output
        ----------
        h: float, degrees
            Maximal altitute of the tile above horizon.        
        """
        dec=np.deg2rad(self.dec)
        lat=np.deg2rad(self.lat)
        sin_h = np.cos(dec-lat)
        h=np.arcsin(sin_h)
        h=np.rad2deg(h)
        return h

        

    def estimate_best_time_interval_to_observe_tile(self):
        """
        Determine hour angle amplitude to estimate time when observing is still acceptable
        """
        dec=np.deg2rad(self.dec)
        lat=np.deg2rad(self.lat)
        
        # If star is above the horizon (our 'horizon' is at ALT_MIN) at all times:
        if self.lat+self.dec+ALT_MIN<-90.0:
            distance_from_the_pole=(90.0+self.dec)# self.dec<0
            alt_low=self.alt_max-2.0*distance_from_the_pole
            h_good_low = alt_low + 2.0*distance_from_the_pole*self.altitude_low_fraction
        else:
            h_good_low = self.alt_max * self.altitude_low_fraction

        if h_good_low<ALT_MIN:
            h_good_low=ALT_MIN            
        h_good_low = np.deg2rad(h_good_low)
        
        cosH = (np.sin(h_good_low) - np.sin(lat)*np.sin(dec)) / (np.cos(lat)*np.cos(dec))

        try:
            H = np.arccos(cosH)
            H = np.rad2deg(H)
            H = np.abs(H)
            H = H / 15.0 # hours
        except:
            H=None # TODO: how to treat |cosH|>1?? This is for circumpolar stars.
        return H

            
    #~ @profile
    def weighting(self, tiles_mag_range=None, internal_observed_tiles_mag_range=None):
        """
        Weighting between H (hour angle), Ranking (priority) and slew time.
        """
        w_altitude = self.weighting_altitude() # [0, 1]
        w_slew_time = self.weighting_slew_time() # [0, 1]
        w_moon = self.weighting_moon_distance()
        w_density = self.weighting_field_density(tiles_mag_range=tiles_mag_range, internal_observed_tiles_mag_range=internal_observed_tiles_mag_range) # [0, 1]
        
        w_ranking = float(self.TaipanTile.priority) / float(self.max_priority) # [0, 1]
        # Some tiles have ranking equal to 0. So we set probability to 0.5:
        if w_ranking<1e-12:
            w_ranking=0.5
        
        # Weighting 1
        w = w_ranking * w_altitude * w_slew_time * w_moon * w_density
        
        # Weighting 1.1, don't do this
        #~ w = w_ranking**2 * w_altitude * w_slew_time * w_moon * w_density
        
        # Weighting 1.2
        #~ w = w_ranking * w_altitude * w_slew_time * w_moon * w_density**6
        
        # Weighting 1.3
        #~ w = w_ranking * w_altitude**2 * w_slew_time**2 * w_moon * w_density**6

        # Weighting 2        
        #~ w = w_ranking + w_altitude + w_slew_time + w_moon + w_density
        #~ w = w/5.0

        # Weighting 3, this is not OK because all the probabilities are very high
        #~ if all(x > 0.0 for x in [w_ranking, w_altitude, w_slew_time, w_moon, w_density]):
            #~ c=[10, 5, 5, 1, 10]
            #~ w = c[0]*w_ranking + c[1]*w_altitude + c[2]*w_slew_time + c[3]*w_moon + c[4]*w_density
            #~ w = w/np.sum(c)
        #~ else:
            #~ w=0.0
        
        self.weight = w

        
    def weighting_altitude(self):
        """
        Return altitude_current / altitude_at_meridian.
        """
        alt=self.alt
        alt_max=self.alt_max # altitude at local meridian

        # If star is above the horizon (our 'horizon' is at ALT_MIN) at all times:
        if self.lat+self.dec+ALT_MIN<-90.0:
            distance_from_the_pole=(90.0+self.dec)# self.dec<0
            alt_min=alt_max-2.0*distance_from_the_pole
            w = float(alt-alt_min)/float(2.0*distance_from_the_pole)
        else:
            w = float(alt)/float(alt_max)
        
        return w

    def weighting_moon_distance(self):
        d=self.angular_moon_distance
        if d<MOON_ANGDIST_MIN:
            w=0.0
        elif d>MOON_ANGDIST_OK:
            w=1
        else:
            k=(1.0-0.5)/(MOON_ANGDIST_OK-MOON_ANGDIST_MIN)
            n=0.5-k*MOON_ANGDIST_MIN
            w=k*d+n
        return w 

    #~ @profile
    def weighting_slew_time(self):
        """
        Slew time function: a maximum of angular distance and difference in azimuth.
        """       
        # Current position:
        ra1=self.ra_current
        dec1=self.dec_current
        
        # Next position:
        ra2=self.TaipanTile.ra
        dec2=self.TaipanTile.dec
        
        angle=self.distance_between_two_points_in_the_sky(alpha1=ra1, delta1=dec1, alpha2=ra2, delta2=dec2)
        if angle>180.0:
			angle=360.0-angle
        
        # Azimuth      
        H1=self.determine_hour_angle(ra=ra1)
        alt1=self.altitude_of_an_object_in_the_sky(hour_angle=H1, dec=dec1)
        az1=self.determine_azimuth(ra=ra1, dec=dec1, alt=alt1, H=H1)
        
        az2=self.determine_azimuth(ra=ra2, dec=dec2, alt=self.alt, H=self.hour_angle)
        
        az=np.abs(az2-az1)
        if az>180.0:
			az=360.0-az
        
          
        # If slew time is less than e.g. 60s (approximate readout time and minimum starbug reconfiguration) then ignore slew time.
        # TODO: how do I know relation between the angle and slew time?

        m=np.max([angle, az])
        result=(180.0 - m) / 180.0
        #~ result=np.exp(-result)

        #~ print 'azimuth', ra1, ra2, dec1, dec2, az1, az2, az, m, result

        return result

    #~ @profile
    def weighting_field_density(self, tiles_mag_range=None, internal_observed_tiles_mag_range=None):
        """
        Determine local field density (for a particular magnitude range)
        """
        ra=self.TaipanTile.ra # deg
        dec=self.TaipanTile.dec # deg
        
        mag_range=(float(self.TaipanTile.mag_min), float(self.TaipanTile.mag_max))

        # Number of observed tiles within the tile_density_radius
        #~ try:
            #~ observed_tiles=self.observed_tiles[mag_range]
        #~ except:
            #~ # No fields were observed yet
            #~ return 1.0

        observed_tiles=internal_observed_tiles_mag_range[mag_range]#self.observed_tiles[mag_range]
        #~ print 'len observed_tiles', mag_range, len(observed_tiles)
        
            
            
            
        n=0
        for x in observed_tiles: # TODO: make hour_angle exclusion loop (because after time number of observed tiles is going to grow (or perhaps not because new tiling will be generated each month)
            if np.abs(ra-x.ra)<self.tile_density_radius and np.abs(dec-x.dec)<self.tile_density_radius:
                #~ print 'IN'
                d=self.distance_between_two_points_in_the_sky(alpha1=ra, delta1=dec, alpha2=x.ra, delta2=x.dec)
                #~ print d
                if d<self.tile_density_radius:
                    n+=1
        n_observed=float(n)


        #~ print 'tile density radius', self.tile_density_radius

        # All candidate tiles from the tiling code within tile_density_radius
        n=0
        ramin=360
        ramax=0
        for x in tiles_mag_range[mag_range]:
            #~ print 'start', 'tile ra', ra, 'tiles ra', x.ra, 'tile dec', dec, 'tiles dec', x.dec
            if x.ra>ramax:
                ramax=x.ra
            if x.ra<ramin:
                ramin=x.ra
            if np.abs(ra-x.ra)<self.tile_density_radius and np.abs(dec-x.dec)<self.tile_density_radius:
                #~ print 'IIIINNNNN', self.tile_density_radius
                d=self.distance_between_two_points_in_the_sky(alpha1=ra, delta1=dec, alpha2=x.ra, delta2=x.dec)
                #~ print 'DDDDDD', d
                if d<self.tile_density_radius:
                    n+=1
        n_total=float(n)

        #~ if n<0.5:
            #~ return 0.0 # apparently out of the range

        if n_total<0.5:
            print 'ramin, ramax', ramin, ramax, ra
            #~ pdb.set_trace()
        
        weight = 1.0 - n_observed / n_total

        #~ print 'n_observed, n_total', n_observed, n_total, weight, 'len(observed_tiles)', len(observed_tiles), mag_range

        self.surface_density=[weight, n_observed, n_total]
        
        if n<0.5:
            return 0.0 # apparently out of the range

        return weight
    

"""
-------------------
Tests
-------------------
All the possible situations:
- only part of the sky is clear

"""

def run_scheduler(time=None, date=None):
    """
    Run scheduler for testing purposes.
    """
    # Basic example with no limitations other than altitude and Moon distance
    s=Scheduler()

    # Example with limitations
    #~ s=Scheduler(tiling_filename=tiling_filename, observed_tiles_filename=observed_tiles_filename, alt_min=20.0, alt_max=50.0, moon_angdist_min=20.0, ra_min=200, ra_max=250, limiting_magnitude=9)
    

    t=s.find_the_best_tile_to_observe_now(time=time, date=date)
    best_tile=t[0]
    print 'Best tile:', best_tile
    s.print_selected_tile_to_json()
    
    for x in t[:10]:
        print x    


    # PLOT
    lst=s.local_sidereal_time*15.0
    if lst>180:
        lst=lst-360.0
    plot_ra_amp=50
    #~ if lst-plot_ra_amp
    moon=s.moon
    w=np.array([[x.TaipanTile.ra, x.TaipanTile.dec, x.weight] for x in t if x.hour_angle<6.0])
    w=np.array([x if x[0]<180 else [x[0]-360.0, x[1], x[2]] for x in w])
    w=np.array(sorted(w, key=lambda y: y[2]))
    tiles=np.array([[x.ra, x.dec] for x in s.tiles])
    tiles=np.array([x if x[0]<180 else [x[0]-360.0, x[1]] for x in tiles])


    import matplotlib.pyplot as plt
    fig=plt.figure()
    ax=fig.add_subplot(111)
    ax.axvline(x=lst)
    ax.scatter(tiles[:,0], tiles[:,1], c='grey', alpha=0.1)
    
    m=[moon.ra.value if moon.ra.value<180.0 else moon.ra.value-360.0, moon.dec.value]
    ax.scatter(m[0], m[1], c='red', s=200)
    cb=ax.scatter(w[:,0], w[:,1], c=w[:,2], vmin=0, vmax=1, cmap=plt.cm.RdYlGn_r)
    plt.colorbar(cb)
    
    bt=[best_tile.TaipanTile.ra if best_tile.TaipanTile.ra<180.0 else best_tile.TaipanTile.ra-360.0, best_tile.TaipanTile.dec]
    #~ ax.scatter([best_tile.TaipanTile.ra], [best_tile.TaipanTile.dec], c='None', edgecolor='r', s=150)
    ax.scatter(bt[0], bt[1], c='None', edgecolor='r', s=150)
    
    # Current telescope position
    ctp=[s.ra_current if s.ra_current<180.0 else s.ra_current-360.0, s.dec_current]
    ax.scatter(ctp[0], ctp[1], c='None', edgecolor='k', s=150)
    
    
    ax.set_xlim([lst-plot_ra_amp, lst+plot_ra_amp])
    #~ plt.show()
    plt.savefig('test.png')
    
    
def observing_plan(date=None, time=None):
    """
    Run observing plan for testing purposes.
    """

    t_start=datetime.datetime.now()

    s=Scheduler()
    telescope_positions=s.make_list_of_best_tiles_through_the_night(date=date, time=time)
    
    t_end=datetime.datetime.now()
    dt=t_end-t_start
    print 'Total time: %d s (%.2f min)'%(dt.seconds, dt.seconds/60.0)
    
    #~ import matplotlib.pyplot as plt
    #~ fig=plt.figure()
    #~ ax=fig.add_subplot(111)
    #~ ax.scatter(telescope_positions[:,2], telescope_positions[:,3], c='r')
    #~ ax.scatter(telescope_positions[:,0], telescope_positions[:,1])
    #~ ax.plot(telescope_positions[:,0], telescope_positions[:,1])
    #~ plt.show()


def test_tile_distribution_in_the_sky(filename):
    """
    Plot RA, Dec of all the candidate tiles from the tiling file.
    """
    fl = open(filename,'rb')
    tiles = pickle.load(fl)[0]
    fl.close()
    print 'Number of tiles:', len(tiles)
    
    c=np.array([[x.ra/15.0, x.dec] for x in tiles])
    
    import matplotlib.pylab as plt
    fig=plt.figure()
    ax=fig.add_subplot(111)
    ax.scatter(c[:,0], c[:,1], s=5)
    plt.show()

def test_read_json_file(filename):
    """
    Check if json file is readable.
    """
    with open(filename) as json_file:  
        data = json.load(json_file)
    print data

     
            
if __name__ == "__main__":
    #~ dir = '/Users/mireland/Google Drive/FunnelWeb/TargetSelection/tiling_results/'
    #~ tiling_filename=dir + '171308_1647_fw_tiling.pkl'
    
    # TODO: remove these filenames.
    # It doesnt care about this names anymore.
    tiling_filename='171308_1647_fw_tiling.pkl'
    observed_tiles_filename='%s_observed_tiles.txt'%tiling_filename[:-4]

    """
    Run Scheduler
    """
    #~ run_scheduler(tiling_filename, observed_tiles_filename, date='2017-11-04', time='16:42:42')
    #~ run_scheduler()
    
    observing_plan(date='2017-11-04', time='02:42:42')

    
    """
    Tests
    """
    #~ test_tile_distribution_in_the_sky(tiling_filename)
    #~ test_read_json_file('selected_tile_2017-10-09--01:42:30.379.json')
    
    
    #~ import pdb
    #~ pdb.set_trace()
    
    #~ reload(fwtl)
    #~ fwtiler = FWTiler(...)
    #~ %run -i script.py
