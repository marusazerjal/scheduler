# FunnelWeb: Decide which tile to observe next, based on sidereal time and observing conditions (weather, seeing etc.).

# Should this code select only one tile to be observe next, or a few best candidates?
# Should this code make an ordered list of fields for the entire night? In this case it should be allowed to run Scheduler multiple times during the night (e.g. if the weather conditions change).

# Assumption: none of the tiles from the input file have not been observed yet. If Scheduler is run muptiple times during the night make sure you exclude tiles that have already been observed this night.
# Tiling will be run about once per month anyway so there should be a list of observed tiles.

# Tile radius: 3 arcmin (6dF)


import numpy as np
import random
import pickle

from astropy.time import Time
from astropy.coordinates import get_moon

# Taipan
import taipan # written for python2
import core as tp
# Have to run the code in python 2. Astropy requires numpy>1.9.1. How to do that? It doesn't work with pip


class Scheduler():
	"""
	Schedule FunnelWeb tile observations.
	"""
	def __init__(self, tiling_filename=None, alt_min=None, alt_max=None, ra_min=None, ra_max=None, moon_angdist_min=None, lat=None, lon=None, desired_priority=None, minimal_priority=None, processing_time=300.0, limiting_magnitude=None):
		"""
        Parameters
        ----------
		tiling_filename: string
			A pickle data filename of tiles generated by the tiling code.
		alt_min: float, degrees
			Minimal allowed altitude of a tile above the horizon. Default: 30.0.
		alt_max: float, degrees
			Maximal allowed altitude of a tile. (Avoid observing zenith). Default: 70.0.
		ra_min, ra_max: float, degrees
			Limit tiles within certain RA limits (e.g. when only part of the sky is clear).
		moon_angdist_min: float, degrees
			Angular distance between the Moon and the tile. Default: 20.0.
		lat, lon: float, degrees
			Observer's latitude and longitude. Default: lat=-31.2749, lon=149.0685 (Siding Spring).
		desired_priority: float
			Desired priority to be observed.
		minimal_priority: float
			User defined minimal tile priority to be observed.
		processing_time: float, seconds
			Total time spend per tile (slewing, exposure, calibration etc.). Default: 300.0.
		limiting_magnitude: float
			Magnitude of a faintest star to be observed. Default: None.
		"""
		
		"""
		Read the data
		"""
		if tiling_filename:
			print 'Reading data...'
			fl = open(tiling_filename,'rb')
			data = pickle.load(fl)
			fl.close()
			
			self.tiles = data[0]
			self.settings = data[2]
			
			print 'Number of tiles:', len(self.tiles)
		else:
			print 'tiling_filename is None.'
			exit(0)
		
		
		"""
		Determine field_id and priority.
		Calculate_the_score should remain here.
		"""
		# TODO: Later remove field_id as tile_id will be already available in the TaipanTiles.
		tiles2=[]
		for tile_id, x in enumerate(self.tiles):
			x.field_id=tile_id
			x.priority=x.calculate_tile_score(method=self.settings['ranking_method'], disqualify_below_min=self.settings['disqualify_below_min'], combined_weight=self.settings['combined_weight'], exp_base=self.settings['exp_base'])
			tiles2.append(x)
		self.tiles=tiles2
		

		"""
		Observer's coordinates
		# Siding Spring Observatory
		"""
		# TODO: this data is automatic result from Google. Check if it is correct
		if lat:
			self.lat=lat
		else:
			self.lat=-31.2749 # deg South
		if lon:
			self.lon=lon
		else:
			self.lon=149.0685 # deg East


		"""
		Minimal altitude of a tile above the horizon.
		"""
		ALT_MIN=30.0
		if alt_min is not None:
			if alt_min<ALT_MIN:
				self.alt_min=alt_min
			else: # user is not allowed to do funny things
				self.alt_min=ALT_MIN
				print 'WARNING: Minimal altitude too low. Set to %g degrees.'%ALT_MIN
		else:
			self.alt_min = ALT_MIN # degrees

		"""
		Maximal tile altitude valid to observe - due to technical obstacles (cannot observe zenith). ???? DO WE NEED THIS?
		"""
		ALT_MAX=70.0
		if alt_max is not None:
			if alt_max<ALT_MAX:
				self.alt_max=alt_max
			else: # user is not allowed to do funny things
				self.alt_max=ALT_MAX
				print 'WARNING: Minimal altitude too low. Set to 10.0 degrees.'
		else:
			self.alt_max = ALT_MAX # degrees

		"""
		
		"""

		"""
		Limiting magnitude
		"""
		if limiting_magnitude:
			self.limiting_magnitude=limiting_magnitude
		else:
			self.limiting_magnitude=None

		"""
		Minimal angular distance to the Moon
		"""
		if moon_angdist_min is not None:
			if moon_angdist_min>15.0: # user is not allowed to do funny things
				self.moon_angdist_min=moon_angdist_min
		else:
			self.moon_angdist_min = 20.0 # degrees	


		"""
		Determine local sidereal time
		"""
		self.utc = Time(Time.now(), format='iso', scale='utc')
		self.local_sidereal_time = self.utc.sidereal_time('mean', longitude=self.lon).value


		"""
		Moon
		"""
		self.moon = get_moon(self.utc)
		# Astropy Moon coordinates agree with Stellarium within a degree. This is good enough for the Scheduler.
		#~ exit(0)


		# User defined settings
		# Manually enter desired priority of the field. If None, tiles with highest priorities will be selected automatically.
		self.desired_priority=desired_priority
		self.minimal_priority=minimal_priority
		# TODO: Error check if value entered is valid
		
		# List of tiles per entire night
		self.processing_time=processing_time


		# At the beginning all tiles are assumed good to observe, then we throw away those not appropriate at the moment
		#~ self.best_tiles_to_observe_now=[ObsTile(TaipanTile=x) for x in self.tiles]
		self.best_tiles_to_observe_now=[ObsTile(tp=x, lat=self.lat, local_sidereal_time=self.local_sidereal_time, moon=self.moon) for x in self.tiles]


	def find_the_best_tile_to_observe_now(self): # A combination of different methods
		"""
		This is a master function. Use multiple methods to find a best tile to be observed now.
		"""
		self.find_tiles_visible_now()
		self.exclude_zenith()
		self.exclude_tiles_below_limiting_magnitude() # user defined
		self.find_tiles_closest_to_local_meridian()
		self.exclude_tiles_too_close_to_the_moon()
		self.tile_priority()
		best_tile=self.best_tiles_to_observe_now
		return best_tile

	def make_list_of_best_tiles_through_the_night(self):
		"""
		Make a list of best tiles observable through the night.
		"""
		todo=True
		
		# Start of the night, end of the night. Time step: self.processing_time
		self.utc = Time(Time.now(), format='iso', scale='utc')
		self.utc.sidereal_time('mean', longitude=self.lon).value
		
		# Order by hour angle, starting from the evening.
		
		

	def find_tiles_visible_now(self):
		"""
		Find tiles with altitude high enough to be observable.
		"""
		visible_tiles=[]
		for x in self.best_tiles_to_observe_now:
			# Skip this tile if not high enough in the sky
			if x.alt<self.alt_min:
				continue
			visible_tiles.append(x)
		self.best_tiles_to_observe_now=visible_tiles

	def exclude_zenith(self):
		"""
		Exclude zenith due to technical obstacles.
		"""
		visible_tiles=[]
		for x in self.best_tiles_to_observe_now:
			# Skip this tile if not high enough in the sky
			if x.alt>self.alt_max:
				continue
			visible_tiles.append(x)
		self.best_tiles_to_observe_now=visible_tiles
		
	def find_tiles_closest_to_local_meridian(self):
		tiles=sorted(self.best_tiles_to_observe_now, key=lambda x: np.abs(x.hour_angle))
		self.best_tiles_to_observe_now=tiles
			
	def exclude_tiles_too_close_to_the_moon(self):
		"""
		Exclude tiles closer than self.moon_angdist_min from the Moon.
		"""
		good_tiles=[x for x in self.best_tiles_to_observe_now if x.angular_moon_distance>self.moon_angdist_min]
		self.best_tiles_to_observe_now=good_tiles
		print 'Number of tiles far enough from the Moon', len(good_tiles)
	
	
	def exclude_tiles_below_limiting_magnitude(self):
		"""
		Exclude tiles within magnitude ranges that include stars fainter than the limiting magnitude.
		"""
		if self.limiting_magnitude:
			good_tiles=[x for x in self.best_tiles_to_observe_now if x.TaipanTile.mag_max<=self.magnitude_limit]
			self.best_tiles_to_observe_now=good_tiles
		else:
			pass
		
	def weather_conditions(self):	
		todo=True
		# Take weather into account
		
		#~ for x in tiles[0][:10]:
			#~ print x, x.ra, x.dec, x.mag_min, x.mag_max
			
	def tile_priority(self):
		# Tile priority: summing up the priorities of the TaipanTargets within the tile.
		if self.minimal_priority:
			good=[x for x in self.best_tiles_to_observe_now if x.TaipanTile.priority>=self.minimal_priority]
			if len(good)<1:
				print 'WARNING: There is no tiles with desired minimal_priority.'
				self.best_tiles_to_observe_now=good
			else:
				good=sorted(good, key=lambda x: x.TaipanTile.priority, reverse=True)
		else:
			# Choose the highest priority tiles
			good=sorted(self.best_tiles_to_observe_now, key=lambda x: x.TaipanTile.priority, reverse=True)
		self.best_tiles_to_observe_now=good	
		# If there is no tiles with minimal_priority, select the next one


		# TODO: DIFFICULTY
		# x.difficulty Difficulty: summing up the difficulties of the TaipanTargets within the tile. ##### WHAT IS THIS? it is probably relevant



class ObsTile():
	"""
	Observational parameters of a tile
	"""
	def __init__(self, tp=None, lat=None, local_sidereal_time=None, moon=None):
		"""
        Parameters
        ----------		
        TaipanTile:
        ra, dec: tile coordinates, degrees
        lat: observer's latitude, degrees
        local_sidereal_time: Local sidereal time, hours
        moon: astropy moon object
        
        hour_angle: Hour angle of a tile at time local_sidereal_time, hours
        alt: altitude of a center of a tile for a given hour_angle, degrees
        angular_moon_distance: Angular distance between the tile and the Moon, degrees
		"""
		self.TaipanTile=tp
		self.ra=tp.ra
		self.dec=tp.dec
		self.lat=lat
		self.local_sidereal_time=local_sidereal_time
		self.moon=moon

		"""
		Compute observational parameters
		"""
		self.hour_angle=self.determine_hour_angle()
		self.alt=self.altitude_of_an_object_in_the_sky()
		self.angular_moon_distance=self.distance_between_two_points_in_the_sky(alpha1=self.ra, delta1=self.dec, alpha2=self.moon.ra.value, delta2=self.moon.dec.value)


	def __str__(self):
		string = 'TP TILE %d: RA=%3.1f, Dec=%2.1f, Ranking=%d, Altitude=%d, H=%.2f, Moon_dist=%d, mag_max=%d' % (self.TaipanTile.field_id, self.TaipanTile.ra, self.TaipanTile.dec, self.TaipanTile.priority, self.alt, self.hour_angle, self.angular_moon_distance, self.TaipanTile.mag_max)
		return string

	def __repr__(self):
		string = 'TP TILE %d: RA=%3.1f, Dec=%2.1f, Ranking=%d, Altitude=%d, H=%.2f, Moon_dist=%d, mag_max=%d' % (self.TaipanTile.field_id, self.TaipanTile.ra, self.TaipanTile.dec, self.TaipanTile.priority, self.alt, self.hour_angle, self.angular_moon_distance, self.TaipanTile.mag_max)
		return string

	def distance_between_two_points_in_the_sky(self, alpha1=None, delta1=None, alpha2=None, delta2=None):
		"""
		Determine the distance between two points in the sky.
		
		Parameters
        ----------
        alpha1, delta1: float, degrees
			RA and Dec for object 1
        alpha2, delta2: float, degrees
			RA and Dec for object 2
        
        Output
        ----------
        A: float, degrees
			Distance between two points in the sky.
		"""
		a1=np.deg2rad(alpha1)
		d1=np.deg2rad(delta1)
		a2=np.deg2rad(alpha2)
		d2=np.deg2rad(delta2)
		
		cos_A = np.sin(d1)*np.sin(d2) + np.cos(d1)*np.cos(d2)*np.cos(a1-a2)
		A=np.arccos(cos_A) # [0, 180] in radians
		A=np.rad2deg(A)
		return A # degrees

	def determine_hour_angle(self):
		"""
		Determine hour angle of a tile.
		
        Output
        ----------
        H: float, degrees
			Hoour angle of the tile.		
		"""
		H = self.local_sidereal_time - self.ra/15.0
		return H

	def altitude_of_an_object_in_the_sky(self):
		"""
		Determine altitude of a tile above horizon.
		
        Output
        ----------
        H: float, degrees
			Hoour angle of the tile.		
		"""
		# No need for atmospheric refraction correction.
		# Disagrees with Stellarium for about 5 degrees (Stellarium is using apparent altitude, but 5 degrees difference was for a star in zenith!!)
		hour_angle=np.deg2rad(self.hour_angle)
		dec=np.deg2rad(self.dec)
		lat=np.deg2rad(self.lat)
		sin_h = np.cos(self.hour_angle)*np.cos(self.dec)*np.cos(self.lat) + np.sin(self.dec)*np.sin(self.lat)
		h=np.arcsin(sin_h)
		h=np.rad2deg(h)
		return h



# Why is altitude determined here, and not in Scheduler (where we can automatically skip tiles too low in the sky so we don't have to determine moon distance etc. of this file: if we are going to determine tile list for the entire night, then altitude changes overnight anyway. But...!

def test_tile_distribution_in_the_sky():
	fl = open('171308_1647_fw_tiling.pkl','rb')
	tiles = pickle.load(fl)[0]
	fl.close()
	print 'Number of tiles:', len(tiles)
	
	c=np.array([[x.ra/15.0, x.dec] for x in tiles])
	
	import matplotlib.pylab as plt
	fig=plt.figure()
	ax=fig.add_subplot(111)
	ax.scatter(c[:,0], c[:,1], s=5)
	plt.show()
	

"""
-------------------
Tests
-------------------
All the possible situations:
- only part of the sky is clear

"""


if __name__ == "__main__":
	#~ test_tile_distribution_in_the_sky()
	#~ exit(0)
	
	s=Scheduler(tiling_filename='171308_1647_fw_tiling.pkl', alt_min=40.0, moon_angdist_min=20.0, minimal_priority=100.0)
	t=s.find_the_best_tile_to_observe_now()[0]
	#~ print 'Best tile:', t.alt, t.hour_angle, t.angular_moon_distance, t.TaipanTile.priority
	print 'Best tile:', t
	
	t2=t=s.find_the_best_tile_to_observe_now()
	for x in t2[:10]:
		print x
	
